<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/AppState.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/AppState.java" />
              <option name="originalContent" value="import java.util.List;&#10;import config.ConfigurationManager;&#10;import personality.PersonalityManager;&#10;import personality.Personality;&#10;&#10;/**&#10; * Simplified AppState - now only holds the current application state.&#10; * Configuration management and personality loading are delegated to specialized managers.&#10; */&#10;public class AppState {&#10;&#10;    // --- Essential Application State ---&#10;    public static volatile boolean isRunning = false;&#10;&#10;    // --- UI Configuration ---&#10;    public static final String FALLBACK_IMAGE_URL = &quot;&quot;;&#10;&#10;    // --- Current Settings (delegated to ConfigurationManager) ---&#10;    public static volatile String selectedTtsCharacterVoice = null;&#10;    public static volatile String selectedLanguage = &quot;English&quot;;&#10;&#10;    /**&#10;     * Initializes the application state by loading all configurations and personalities.&#10;     * This should be called once at application startup.&#10;     */&#10;    public static void initialize() {&#10;        // Initialize configuration management&#10;        ConfigurationManager.initialize();&#10;&#10;        // Load personalities&#10;        PersonalityManager.loadPersonalities();&#10;&#10;        // Apply user settings to AppState variables&#10;        applyUserSettings();&#10;&#10;        // Apply personality selection from user settings&#10;        PersonalityManager.applyPersonalityFromSettings();&#10;&#10;        System.out.println(&quot;AppState initialized successfully.&quot;);&#10;    }&#10;&#10;    /**&#10;     * Applies user settings to the AppState variables.&#10;     */&#10;    private static void applyUserSettings() {&#10;        selectedTtsCharacterVoice = ConfigurationManager.getSelectedTtsVoice();&#10;        selectedLanguage = ConfigurationManager.getSelectedLanguage();&#10;    }&#10;&#10;    /**&#10;     * Saves all current settings to user settings file.&#10;     */&#10;    public static void saveCurrentSettings() {&#10;        ConfigurationManager.setSelectedTtsVoice(selectedTtsCharacterVoice);&#10;        ConfigurationManager.setSelectedLanguage(selectedLanguage);&#10;    }&#10;&#10;    // === Personality Delegation Methods ===&#10;&#10;    public static List&lt;Personality&gt; getAvailablePersonalities() {&#10;        return PersonalityManager.getAvailablePersonalities();&#10;    }&#10;&#10;    public static void setSelectedPersonality(Personality personality) {&#10;        PersonalityManager.setSelectedPersonality(personality);&#10;    }&#10;&#10;    public static Personality getSelectedPersonality() {&#10;        return PersonalityManager.getSelectedPersonality();&#10;    }&#10;&#10;    public static String getCurrentPersonalityPrompt() {&#10;        return PersonalityManager.getCurrentPersonalityPrompt();&#10;    }&#10;&#10;    // === Configuration Delegation Methods ===&#10;&#10;    public static boolean isVisionApiConfigAvailable() {&#10;        return ConfigurationManager.isVisionApiAvailable();&#10;    }&#10;&#10;    public static boolean isAnalysisApiConfigAvailable() {&#10;        return ConfigurationManager.isAnalysisApiAvailable();&#10;    }&#10;&#10;    public static void setUseApiVision(boolean useApi) {&#10;        ConfigurationManager.setUseApiVision(useApi);&#10;        System.out.println(&quot;Vision model changed to: &quot; + (useApi ? &quot;API&quot; : &quot;Local&quot;));&#10;    }&#10;&#10;    public static void setUseApiAnalysis(boolean useApi) {&#10;        ConfigurationManager.setUseApiAnalysis(useApi);&#10;        System.out.println(&quot;Analysis model changed to: &quot; + (useApi ? &quot;API&quot; : &quot;Local&quot;));&#10;    }&#10;&#10;    public static boolean useApiVision() {&#10;        return ConfigurationManager.useApiVision();&#10;    }&#10;&#10;    public static boolean useApiAnalysis() {&#10;        return ConfigurationManager.useApiAnalysis();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import java.util.List;&#10;import config.ConfigurationManager;&#10;import personality.PersonalityManager;&#10;import personality.Personality;&#10;&#10;/**&#10; * Simplified AppState - now only holds the current application state.&#10; * Configuration management and personality loading are delegated to specialized managers.&#10; */&#10;public class AppState {&#10;&#10;    // --- Essential Application State ---&#10;    public static volatile boolean isRunning = false;&#10;&#10;    // --- UI Configuration ---&#10;    public static final String FALLBACK_IMAGE_URL = &quot;src/pngegg.png&quot;;&#10;&#10;    // --- Current Settings (delegated to ConfigurationManager) ---&#10;    public static volatile String selectedTtsCharacterVoice = null;&#10;    public static volatile String selectedLanguage = &quot;English&quot;;&#10;&#10;    /**&#10;     * Initializes the application state by loading all configurations and personalities.&#10;     * This should be called once at application startup.&#10;     */&#10;    public static void initialize() {&#10;        // Initialize configuration management&#10;        ConfigurationManager.initialize();&#10;&#10;        // Load personalities&#10;        PersonalityManager.loadPersonalities();&#10;&#10;        // Apply user settings to AppState variables&#10;        applyUserSettings();&#10;&#10;        // Apply personality selection from user settings&#10;        PersonalityManager.applyPersonalityFromSettings();&#10;&#10;        System.out.println(&quot;AppState initialized successfully.&quot;);&#10;    }&#10;&#10;    /**&#10;     * Applies user settings to the AppState variables.&#10;     */&#10;    private static void applyUserSettings() {&#10;        selectedTtsCharacterVoice = ConfigurationManager.getSelectedTtsVoice();&#10;        selectedLanguage = ConfigurationManager.getSelectedLanguage();&#10;    }&#10;&#10;    /**&#10;     * Saves all current settings to user settings file.&#10;     */&#10;    public static void saveCurrentSettings() {&#10;        ConfigurationManager.setSelectedTtsVoice(selectedTtsCharacterVoice);&#10;        ConfigurationManager.setSelectedLanguage(selectedLanguage);&#10;    }&#10;&#10;    // === Personality Delegation Methods ===&#10;&#10;    public static List&lt;Personality&gt; getAvailablePersonalities() {&#10;        return PersonalityManager.getAvailablePersonalities();&#10;    }&#10;&#10;    public static void setSelectedPersonality(Personality personality) {&#10;        PersonalityManager.setSelectedPersonality(personality);&#10;        // Update UI after personality change&#10;        if (Main.characterUI != null) {&#10;            Main.characterUI.updatePersonalityImages();&#10;        }&#10;    }&#10;&#10;    public static Personality getSelectedPersonality() {&#10;        return PersonalityManager.getSelectedPersonality();&#10;    }&#10;&#10;    public static String getCurrentPersonalityPrompt() {&#10;        return PersonalityManager.getCurrentPersonalityPrompt();&#10;    }&#10;&#10;    // === Configuration Delegation Methods ===&#10;&#10;    public static boolean isVisionApiConfigAvailable() {&#10;        return ConfigurationManager.isVisionApiAvailable();&#10;    }&#10;&#10;    public static boolean isAnalysisApiConfigAvailable() {&#10;        return ConfigurationManager.isAnalysisApiAvailable();&#10;    }&#10;&#10;    public static void setUseApiVision(boolean useApi) {&#10;        ConfigurationManager.setUseApiVision(useApi);&#10;        System.out.println(&quot;Vision model changed to: &quot; + (useApi ? &quot;API&quot; : &quot;Local&quot;));&#10;    }&#10;&#10;    public static void setUseApiAnalysis(boolean useApi) {&#10;        ConfigurationManager.setUseApiAnalysis(useApi);&#10;        System.out.println(&quot;Analysis model changed to: &quot; + (useApi ? &quot;API&quot; : &quot;Local&quot;));&#10;    }&#10;&#10;    public static boolean useApiVision() {&#10;        return ConfigurationManager.useApiVision();&#10;    }&#10;&#10;    public static boolean useApiAnalysis() {&#10;        return ConfigurationManager.useApiAnalysis();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/AssistantCore.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/AssistantCore.java" />
              <option name="originalContent" value="import java.awt.*;&#10;import java.awt.image.BufferedImage;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.ScheduledExecutorService;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.concurrent.atomic.AtomicBoolean;&#10;&#10;import api.ApiClient;&#10;import api.TtsApiClient;&#10;import personality.PersonalityManager;&#10;import config.ConfigurationManager;&#10;&#10;/**&#10; * Simplified AssistantCore - now only orchestrates the AI processing pipeline.&#10; * Heavy lifting is delegated to specialized managers and API clients.&#10; */&#10;public class AssistantCore {&#10;&#10;    private ScheduledExecutorService scheduler;&#10;    private final List&lt;BufferedImage&gt; screenshotBuffer = new ArrayList&lt;&gt;();&#10;    private final AtomicBoolean isProcessing = new AtomicBoolean(false);&#10;&#10;    public void startProcessing() {&#10;        if (AppState.isRunning) return;&#10;        scheduler = Executors.newScheduledThreadPool(2);&#10;        scheduler.scheduleAtFixedRate(this::captureScreenshot, 0, 500, TimeUnit.MILLISECONDS);&#10;        scheduler.scheduleAtFixedRate(this::processAndRespond, 3, 5, TimeUnit.SECONDS);&#10;        AppState.isRunning = true;&#10;        System.out.println(&quot;AI Assistant background tasks started.&quot;);&#10;    }&#10;&#10;    public void stopProcessing() {&#10;        if (!AppState.isRunning) return;&#10;        if (scheduler != null &amp;&amp; !scheduler.isShutdown()) {&#10;            scheduler.shutdownNow();&#10;        }&#10;        AppState.isRunning = false;&#10;        System.out.println(&quot;AI Assistant background tasks stopped.&quot;);&#10;    }&#10;&#10;    private void captureScreenshot() {&#10;        try {&#10;            Robot robot = new Robot();&#10;            Rectangle screenRect = new Rectangle(Toolkit.getDefaultToolkit().getScreenSize());&#10;            BufferedImage screenshot = robot.createScreenCapture(screenRect);&#10;            synchronized (screenshotBuffer) {&#10;                screenshotBuffer.add(screenshot);&#10;                if (screenshotBuffer.size() &gt; 4) {&#10;                    screenshotBuffer.removeFirst();&#10;                }&#10;            }&#10;        } catch (AWTException e) {&#10;            e.printStackTrace();&#10;            stopProcessing();&#10;        }&#10;    }&#10;&#10;    private void processAndRespond() {&#10;        if (!isProcessing.compareAndSet(false, true)) {&#10;            return;&#10;        }&#10;&#10;        List&lt;BufferedImage&gt; images;&#10;        synchronized (screenshotBuffer) {&#10;            if (screenshotBuffer.isEmpty()) {&#10;                isProcessing.set(false);&#10;                return;&#10;            }&#10;            images = new ArrayList&lt;&gt;();&#10;            images.add(screenshotBuffer.getLast());&#10;            screenshotBuffer.clear();&#10;        }&#10;&#10;        new Thread(() -&gt; {&#10;            try {&#10;                System.out.println(&quot;Analyzing screenshot with vision service...&quot;);&#10;                String imageDescription = analyzeImage(images.getFirst());&#10;&#10;                if (imageDescription == null || imageDescription.isBlank()) {&#10;                    System.err.println(&quot;Vision service did not return a description.&quot;);&#10;                } else {&#10;                    System.out.println(&quot;Vision service description: &quot; + imageDescription);&#10;                    System.out.println(&quot;Generating final response with language model...&quot;);&#10;                    String rawResponse = generateResponse(imageDescription);&#10;                    String finalResponseToSpeak = parseFinalResponse(rawResponse);&#10;&#10;                    if (finalResponseToSpeak != null &amp;&amp; !finalResponseToSpeak.isBlank()) {&#10;                        System.out.println(&quot;Final response: &quot; + rawResponse);&#10;                        System.out.println(&quot;Speaking: &quot; + finalResponseToSpeak);&#10;&#10;                        // Speak the response - TtsApiClient will handle UI updates automatically&#10;                        TtsApiClient.speak(finalResponseToSpeak, AppState.selectedTtsCharacterVoice, 1.0, AppState.selectedLanguage);&#10;&#10;                        // Save to memory&#10;                        PersonalityManager.saveResponseToMemory(finalResponseToSpeak);&#10;                    }&#10;                }&#10;            } catch (Exception e) {&#10;                System.err.println(&quot;An error occurred during AI processing: &quot; + e.getMessage());&#10;                e.printStackTrace();&#10;            } finally {&#10;                isProcessing.set(false);&#10;            }&#10;        }).start();&#10;    }&#10;&#10;    /**&#10;     * Analyzes the given image using the appropriate vision service.&#10;     */&#10;    private String analyzeImage(BufferedImage image) throws Exception {&#10;        String prompt = &quot;Describe the user's activity in this image. Focus on the content and what they are doing. Do NOT use the words 'screenshot', 'screen', or 'image'.&quot;;&#10;        return ApiClient.analyzeImage(image, prompt);&#10;    }&#10;&#10;    /**&#10;     * Generates a response based on the image description and current personality.&#10;     */&#10;    private String generateResponse(String context) throws Exception {&#10;        String personalityPrompt = PersonalityManager.getCurrentPersonalityPrompt();&#10;&#10;        if (personalityPrompt == null) {&#10;            System.err.println(&quot;No personality selected, using fallback prompt.&quot;);&#10;            String fallbackPrompt = &quot;Based on this screen description: \&quot;%s\&quot; Give a SHORT comment (maximum 15 words).&quot;;&#10;            return ApiClient.generateResponse(String.format(fallbackPrompt, context.replace(&quot;\&quot;&quot;, &quot;'&quot;)));&#10;        }&#10;&#10;        String lastResponse = PersonalityManager.getLastResponse();&#10;&#10;        // Build the final prompt with the personality and memory context&#10;        StringBuilder promptBuilder = new StringBuilder();&#10;        promptBuilder.append(String.format(personalityPrompt, context.replace(&quot;\&quot;&quot;, &quot;'&quot;)));&#10;&#10;        // Add the memory instruction if a previous response exists&#10;        if (lastResponse != null &amp;&amp; !lastResponse.isEmpty()) {&#10;            promptBuilder.append(&quot;Do not use special characters, formatting or emojis in your response.&quot;);&#10;            promptBuilder.append(&quot; Your previous comment was: \&quot;&quot;);&#10;            promptBuilder.append(lastResponse.replace(&quot;\&quot;&quot;, &quot;'&quot;));&#10;            promptBuilder.append(&quot;\&quot;. Your new comment MUST be different.&quot;);&#10;        }&#10;&#10;        String finalPrompt = promptBuilder.toString();&#10;        System.out.println(&quot;Final prompt sent to LLM: &quot; + finalPrompt);&#10;&#10;        return ApiClient.generateResponse(finalPrompt);&#10;    }&#10;&#10;    /**&#10;     * Parses the final response to remove thinking tags if present.&#10;     */&#10;    private String parseFinalResponse(String rawResponse) {&#10;        if (rawResponse == null) {&#10;            return null;&#10;        }&#10;        int thinkTagEnd = rawResponse.lastIndexOf(&quot;&lt;/think&gt;&quot;);&#10;        if (thinkTagEnd != -1) {&#10;            return rawResponse.substring(thinkTagEnd + &quot;&lt;/think&gt;&quot;.length()).trim();&#10;        }&#10;        return rawResponse.trim();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import java.awt.*;&#10;import java.awt.image.BufferedImage;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.concurrent.Executors;&#10;import java.util.concurrent.ScheduledExecutorService;&#10;import java.util.concurrent.TimeUnit;&#10;import java.util.concurrent.atomic.AtomicBoolean;&#10;&#10;import api.ApiClient;&#10;import api.TtsApiClient;&#10;import personality.PersonalityManager;&#10;import config.ConfigurationManager;&#10;&#10;/**&#10; * Simplified AssistantCore - now only orchestrates the AI processing pipeline.&#10; * Heavy lifting is delegated to specialized managers and API clients.&#10; */&#10;public class AssistantCore {&#10;&#10;    private ScheduledExecutorService scheduler;&#10;    private final List&lt;BufferedImage&gt; screenshotBuffer = new ArrayList&lt;&gt;();&#10;    private final AtomicBoolean isProcessing = new AtomicBoolean(false);&#10;&#10;    public void startProcessing() {&#10;        if (AppState.isRunning) return;&#10;        scheduler = Executors.newScheduledThreadPool(2);&#10;        scheduler.scheduleAtFixedRate(this::captureScreenshot, 0, 500, TimeUnit.MILLISECONDS);&#10;        scheduler.scheduleAtFixedRate(this::processAndRespond, 3, 5, TimeUnit.SECONDS);&#10;        AppState.isRunning = true;&#10;        System.out.println(&quot;AI Assistant background tasks started.&quot;);&#10;    }&#10;&#10;    public void stopProcessing() {&#10;        if (!AppState.isRunning) return;&#10;        if (scheduler != null &amp;&amp; !scheduler.isShutdown()) {&#10;            scheduler.shutdownNow();&#10;        }&#10;        AppState.isRunning = false;&#10;        System.out.println(&quot;AI Assistant background tasks stopped.&quot;);&#10;    }&#10;&#10;    private void captureScreenshot() {&#10;        try {&#10;            Robot robot = new Robot();&#10;            Rectangle screenRect = new Rectangle(Toolkit.getDefaultToolkit().getScreenSize());&#10;            BufferedImage screenshot = robot.createScreenCapture(screenRect);&#10;            synchronized (screenshotBuffer) {&#10;                screenshotBuffer.add(screenshot);&#10;                if (screenshotBuffer.size() &gt; 4) {&#10;                    screenshotBuffer.removeFirst();&#10;                }&#10;            }&#10;        } catch (AWTException e) {&#10;            e.printStackTrace();&#10;            stopProcessing();&#10;        }&#10;    }&#10;&#10;    private void processAndRespond() {&#10;        if (!isProcessing.compareAndSet(false, true)) {&#10;            return;&#10;        }&#10;&#10;        List&lt;BufferedImage&gt; images;&#10;        synchronized (screenshotBuffer) {&#10;            if (screenshotBuffer.isEmpty()) {&#10;                isProcessing.set(false);&#10;                return;&#10;            }&#10;            images = new ArrayList&lt;&gt;();&#10;            images.add(screenshotBuffer.getLast());&#10;            screenshotBuffer.clear();&#10;        }&#10;&#10;        new Thread(() -&gt; {&#10;            try {&#10;                System.out.println(&quot;Analyzing screenshot with vision service...&quot;);&#10;                String imageDescription = analyzeImage(images.getFirst());&#10;&#10;                if (imageDescription == null || imageDescription.isBlank()) {&#10;                    System.err.println(&quot;Vision service did not return a description.&quot;);&#10;                } else {&#10;                    System.out.println(&quot;Vision service description: &quot; + imageDescription);&#10;                    System.out.println(&quot;Generating final response with language model...&quot;);&#10;                    String rawResponse = generateResponse(imageDescription);&#10;                    String finalResponseToSpeak = parseFinalResponse(rawResponse);&#10;&#10;                    if (finalResponseToSpeak != null &amp;&amp; !finalResponseToSpeak.isBlank()) {&#10;                        System.out.println(&quot;Final response: &quot; + rawResponse);&#10;                        System.out.println(&quot;Speaking: &quot; + finalResponseToSpeak);&#10;&#10;                        // Speak the response - TtsApiClient will handle UI updates automatically&#10;                        TtsApiClient.speak(finalResponseToSpeak, AppState.selectedTtsCharacterVoice, 1.0, AppState.selectedLanguage);&#10;&#10;                        // Save to memory&#10;                        PersonalityManager.saveResponseToMemory(finalResponseToSpeak);&#10;                    }&#10;                }&#10;            } catch (Exception e) {&#10;                System.err.println(&quot;An error occurred during AI processing: &quot; + e.getMessage());&#10;                e.printStackTrace();&#10;            } finally {&#10;                isProcessing.set(false);&#10;            }&#10;        }).start();&#10;    }&#10;&#10;    /**&#10;     * Analyzes the given image using the appropriate vision service.&#10;     */&#10;    private String analyzeImage(BufferedImage image) throws Exception {&#10;        String prompt = ConfigurationManager.getVisionPrompt();&#10;        return ApiClient.analyzeImage(image, prompt);&#10;    }&#10;&#10;    /**&#10;     * Generates a response based on the image description and current personality.&#10;     */&#10;    private String generateResponse(String context) throws Exception {&#10;        String personalityPrompt = PersonalityManager.getCurrentPersonalityPrompt();&#10;&#10;        if (personalityPrompt == null) {&#10;            System.err.println(&quot;No personality selected, using fallback prompt.&quot;);&#10;            String fallbackPrompt = ConfigurationManager.getFallbackPrompt();&#10;            return ApiClient.generateResponse(String.format(fallbackPrompt, context.replace(&quot;\&quot;&quot;, &quot;'&quot;)));&#10;        }&#10;&#10;        String lastResponse = PersonalityManager.getLastResponse();&#10;&#10;        // Build the final prompt with the personality and memory context&#10;        StringBuilder promptBuilder = new StringBuilder();&#10;        promptBuilder.append(String.format(personalityPrompt, context.replace(&quot;\&quot;&quot;, &quot;'&quot;)));&#10;&#10;        // Add the memory instruction if a previous response exists&#10;        if (lastResponse != null &amp;&amp; !lastResponse.isEmpty()) {&#10;            promptBuilder.append(&quot;Do not use special characters, formatting or emojis in your response.&quot;);&#10;            promptBuilder.append(&quot; Your previous comment was: \&quot;&quot;);&#10;            promptBuilder.append(lastResponse.replace(&quot;\&quot;&quot;, &quot;'&quot;));&#10;            promptBuilder.append(&quot;\&quot;. Your new comment MUST be different.&quot;);&#10;        }&#10;&#10;        String finalPrompt = promptBuilder.toString();&#10;        System.out.println(&quot;Final prompt sent to LLM: &quot; + finalPrompt);&#10;&#10;        return ApiClient.generateResponse(finalPrompt);&#10;    }&#10;&#10;    /**&#10;     * Parses the final response to remove thinking tags if present.&#10;     */&#10;    private String parseFinalResponse(String rawResponse) {&#10;        if (rawResponse == null) {&#10;            return null;&#10;        }&#10;        int thinkTagEnd = rawResponse.lastIndexOf(&quot;&lt;/think&gt;&quot;);&#10;        if (thinkTagEnd != -1) {&#10;            return rawResponse.substring(thinkTagEnd + &quot;&lt;/think&gt;&quot;.length()).trim();&#10;        }&#10;        return rawResponse.trim();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/CharacterUI.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/CharacterUI.java" />
              <option name="originalContent" value="import javax.imageio.ImageIO;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import java.io.File;&#10;import java.io.IOException;&#10;import personality.Personality;&#10;&#10;/**&#10; * Creates the always-on-top, transparent window for the assistant's image.&#10; * UPDATED: Now manages both static and speaking images for the current personality.&#10; */&#10;public class CharacterUI extends JWindow {&#10;    private SpeechBubble currentBubble;&#10;    private final JLabel imageLabel;&#10;    private ImageIcon staticIcon;&#10;    private ImageIcon speakingIcon;&#10;&#10;    public CharacterUI() {&#10;        imageLabel = new JLabel();&#10;        setBackground(new Color(0, 0, 0, 0));&#10;        add(imageLabel);&#10;        setAlwaysOnTop(true);&#10;&#10;        // Initial image update&#10;        updatePersonalityImages();&#10;&#10;        // Position the window at the bottom right of the screen&#10;        // MOVED pack() to after the image is set to ensure correct sizing.&#10;        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();&#10;        setLocation(screenSize.width - getWidth(), screenSize.height - getHeight());&#10;    }&#10;&#10;    /**&#10;     * Loads the images for the currently selected personality in AppState.&#10;     */&#10;    public void updatePersonalityImages() {&#10;        Personality current = AppState.selectedPersonality;&#10;        if (current == null) {&#10;            System.err.println(&quot;Cannot update images, no personality selected.&quot;);&#10;            return;&#10;        }&#10;&#10;        staticIcon = loadImageIcon(current.getStaticImagePath());&#10;        speakingIcon = loadImageIcon(current.getSpeakingImagePath());&#10;&#10;        // Set the initial image to static&#10;        showStaticImage();&#10;    }&#10;&#10;    private ImageIcon loadImageIcon(String path) {&#10;        try {&#10;            Image image = ImageIO.read(new File(path));&#10;            image = image.getScaledInstance(200, 200, Image.SCALE_SMOOTH);&#10;            return new ImageIcon(image);&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Failed to load image: &quot; + path + &quot;. Using fallback.&quot;);&#10;            // Try to load the fallback image&#10;            try {&#10;                Image fallbackImage = ImageIO.read(new File(AppState.FALLBACK_IMAGE_URL));&#10;                fallbackImage = fallbackImage.getScaledInstance(200, 200, Image.SCALE_SMOOTH);&#10;                return new ImageIcon(fallbackImage);&#10;            } catch (IOException ex) {&#10;                System.err.println(&quot;Failed to load fallback image as well.&quot;);&#10;                return new ImageIcon(); // Return an empty icon&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Displays the 'speaking' image. Should be called from the Event Dispatch Thread.&#10;     */&#10;    public void showSpeakingImage() {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            imageLabel.setIcon(speakingIcon);&#10;            packAndReposition(); // Use helper to resize and position&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Displays the 'static' image. Should be called from the Event Dispatch Thread.&#10;     */&#10;    public void showStaticImage() {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            imageLabel.setIcon(staticIcon);&#10;            packAndReposition(); // Use helper to resize and position&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Helper method to pack the window and reposition it at the bottom right.&#10;     * This ensures the window is correctly sized after an image is set.&#10;     */&#10;    private void packAndReposition() {&#10;        pack();&#10;        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();&#10;        setLocation(screenSize.width - getWidth(), screenSize.height - getHeight());&#10;    }&#10;&#10;&#10;    public void showSpeechBubble(String text) {&#10;        hideSpeechBubble();&#10;        currentBubble = new SpeechBubble(text);&#10;        currentBubble.showAbove(this);&#10;    }&#10;&#10;    public void hideSpeechBubble() {&#10;        if (currentBubble != null) {&#10;            currentBubble.hideBubble();&#10;            currentBubble = null;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import javax.imageio.ImageIO;&#10;import javax.swing.*;&#10;import java.awt.*;&#10;import java.io.File;&#10;import java.io.IOException;&#10;import personality.Personality;&#10;&#10;/**&#10; * Creates the always-on-top, transparent window for the assistant's image.&#10; * UPDATED: Now manages both static and speaking images for the current personality.&#10; */&#10;public class CharacterUI extends JWindow {&#10;    private SpeechBubble currentBubble;&#10;    private final JLabel imageLabel;&#10;    private ImageIcon staticIcon;&#10;    private ImageIcon speakingIcon;&#10;&#10;    public CharacterUI() {&#10;        imageLabel = new JLabel();&#10;        setBackground(new Color(0, 0, 0, 0));&#10;        add(imageLabel);&#10;        setAlwaysOnTop(true);&#10;&#10;        // Initial image update&#10;        updatePersonalityImages();&#10;&#10;        // Position the window at the bottom right of the screen&#10;        // MOVED pack() to after the image is set to ensure correct sizing.&#10;        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();&#10;        setLocation(screenSize.width - getWidth(), screenSize.height - getHeight());&#10;    }&#10;&#10;    /**&#10;     * Loads the images for the currently selected personality in AppState.&#10;     */&#10;    public void updatePersonalityImages() {&#10;        Personality current = AppState.getSelectedPersonality();&#10;        if (current == null) {&#10;            System.err.println(&quot;Cannot update images, no personality selected.&quot;);&#10;            return;&#10;        }&#10;&#10;        staticIcon = loadImageIcon(current.getStaticImagePath());&#10;        speakingIcon = loadImageIcon(current.getSpeakingImagePath());&#10;&#10;        // Set the initial image to static&#10;        showStaticImage();&#10;    }&#10;&#10;    private ImageIcon loadImageIcon(String path) {&#10;        try {&#10;            Image image = ImageIO.read(new File(path));&#10;            image = image.getScaledInstance(200, 200, Image.SCALE_SMOOTH);&#10;            return new ImageIcon(image);&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Failed to load image: &quot; + path + &quot;. Using fallback.&quot;);&#10;            // Try to load the fallback image&#10;            try {&#10;                Image fallbackImage = ImageIO.read(new File(AppState.FALLBACK_IMAGE_URL));&#10;                fallbackImage = fallbackImage.getScaledInstance(200, 200, Image.SCALE_SMOOTH);&#10;                return new ImageIcon(fallbackImage);&#10;            } catch (IOException ex) {&#10;                System.err.println(&quot;Failed to load fallback image as well.&quot;);&#10;                return new ImageIcon(); // Return an empty icon&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Displays the 'speaking' image. Should be called from the Event Dispatch Thread.&#10;     */&#10;    public void showSpeakingImage() {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            imageLabel.setIcon(speakingIcon);&#10;            packAndReposition(); // Use helper to resize and position&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Displays the 'static' image. Should be called from the Event Dispatch Thread.&#10;     */&#10;    public void showStaticImage() {&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            imageLabel.setIcon(staticIcon);&#10;            packAndReposition(); // Use helper to resize and position&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Helper method to pack the window and reposition it at the bottom right.&#10;     * This ensures the window is correctly sized after an image is set.&#10;     */&#10;    private void packAndReposition() {&#10;        pack();&#10;        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();&#10;        setLocation(screenSize.width - getWidth(), screenSize.height - getHeight());&#10;    }&#10;&#10;&#10;    public void showSpeechBubble(String text) {&#10;        hideSpeechBubble();&#10;        currentBubble = new SpeechBubble(text);&#10;        currentBubble.showAbove(this);&#10;    }&#10;&#10;    public void hideSpeechBubble() {&#10;        if (currentBubble != null) {&#10;            currentBubble.hideBubble();&#10;            currentBubble = null;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Main.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Main.java" />
              <option name="originalContent" value="import javax.swing.*;&#10;import java.util.List;&#10;import api.TtsApiClient;&#10;&#10;/**&#10; * The main entry point for the AI Assistant application.&#10; * UPDATED: Now uses the new modular architecture with specialized managers.&#10; */&#10;public class Main {&#10;    public static AssistantCore assistantCore;&#10;    public static CharacterUI characterUI;&#10;&#10;    public static void main(String[] args) {&#10;        System.out.println(&quot;Initializing AI Assistant...&quot;);&#10;&#10;        // Initialize the application state and all managers&#10;        AppState.initialize();&#10;&#10;        System.out.println(&quot;Fetching available TTS characters...&quot;);&#10;        List&lt;String&gt; voices = TtsApiClient.getAvailableCharacters();&#10;&#10;        if (voices == null || voices.isEmpty()) {&#10;            JOptionPane.showMessageDialog(null, &quot;Could not connect to the TTS API Server.\nPlease ensure api.py is running.&quot;, &quot;Connection Error&quot;, JOptionPane.ERROR_MESSAGE);&#10;            return;&#10;        }&#10;&#10;        // Set default voice if none was loaded from settings&#10;        if (AppState.selectedTtsCharacterVoice == null &amp;&amp; !voices.isEmpty()) {&#10;            AppState.selectedTtsCharacterVoice = voices.get(0);&#10;            AppState.saveCurrentSettings();&#10;        }&#10;&#10;        System.out.println(&quot;TTS voices found. Selected voice: &quot; + AppState.selectedTtsCharacterVoice);&#10;&#10;        assistantCore = new AssistantCore();&#10;&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            // Create CharacterUI first so it can be updated by SettingsWindow&#10;            characterUI = new CharacterUI();&#10;            characterUI.setVisible(true);&#10;&#10;            // Now create SettingsWindow&#10;            new SettingsWindow(voices.toArray(new String[0]));&#10;        });&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import javax.swing.*;&#10;import java.util.List;&#10;import api.TtsApiClient;&#10;&#10;/**&#10; * The main entry point for the AI Assistant application.&#10; * UPDATED: Now uses the new modular architecture with specialized managers.&#10; */&#10;public class Main {&#10;    public static AssistantCore assistantCore;&#10;    public static CharacterUI characterUI;&#10;&#10;    public static void main(String[] args) {&#10;        System.out.println(&quot;Initializing AI Assistant...&quot;);&#10;&#10;        // Initialize the application state and all managers&#10;        AppState.initialize();&#10;&#10;        System.out.println(&quot;Fetching available TTS characters...&quot;);&#10;        List&lt;String&gt; voices = TtsApiClient.getAvailableCharacters();&#10;&#10;        if (voices == null || voices.isEmpty()) {&#10;            JOptionPane.showMessageDialog(null, &quot;Could not connect to the TTS API Server.\nPlease ensure api.py is running.&quot;, &quot;Connection Error&quot;, JOptionPane.ERROR_MESSAGE);&#10;            return;&#10;        }&#10;&#10;        // Set default voice if none was loaded from settings&#10;        if (AppState.selectedTtsCharacterVoice == null &amp;&amp; !voices.isEmpty()) {&#10;            AppState.selectedTtsCharacterVoice = voices.get(0);&#10;            AppState.saveCurrentSettings();&#10;        }&#10;&#10;        System.out.println(&quot;TTS voices found. Selected voice: &quot; + AppState.selectedTtsCharacterVoice);&#10;&#10;        assistantCore = new AssistantCore();&#10;&#10;        SwingUtilities.invokeLater(() -&gt; {&#10;            // Create CharacterUI first so it can be updated by SettingsWindow&#10;            characterUI = new CharacterUI();&#10;            characterUI.setVisible(true);&#10;            &#10;            // Set up TTS UI callback so TtsApiClient can control the UI properly&#10;            TtsApiClient.setUICallback(new TtsApiClient.UICallback() {&#10;                @Override&#10;                public void showSpeakingImage() {&#10;                    characterUI.showSpeakingImage();&#10;                }&#10;                &#10;                @Override&#10;                public void showSpeechBubble(String text) {&#10;                    characterUI.showSpeechBubble(text);&#10;                }&#10;                &#10;                @Override&#10;                public void showStaticImage() {&#10;                    characterUI.showStaticImage();&#10;                }&#10;                &#10;                @Override&#10;                public void hideSpeechBubble() {&#10;                    characterUI.hideSpeechBubble();&#10;                }&#10;            });&#10;&#10;            // Now create SettingsWindow&#10;            new SettingsWindow(voices.toArray(new String[0]));&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/SettingsWindow.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/SettingsWindow.java" />
              <option name="originalContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.ItemEvent;&#10;import java.util.List;&#10;&#10;/**&#10; * Creates the main settings window for the application.&#10; * UPDATED: Now uses the new modular architecture with specialized managers.&#10; */&#10;public class SettingsWindow extends JFrame {&#10;&#10;    public SettingsWindow(String[] voices) {&#10;        setTitle(&quot;AI Assistant Settings&quot;);&#10;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        setSize(500, 450);&#10;&#10;        JPanel panel = new JPanel(new GridBagLayout());&#10;        GridBagConstraints gbc = new GridBagConstraints();&#10;        gbc.insets = new Insets(5, 10, 5, 10);&#10;        gbc.fill = GridBagConstraints.HORIZONTAL;&#10;&#10;        // --- Voice Controls ---&#10;        gbc.gridx = 0;&#10;        gbc.gridy = 0;&#10;        panel.add(new JLabel(&quot;Assistant Voice:&quot;), gbc);&#10;&#10;        gbc.gridx = 1;&#10;        gbc.gridy = 0;&#10;        JComboBox&lt;String&gt; voiceSelector = new JComboBox&lt;&gt;(voices);&#10;        voiceSelector.setSelectedItem(AppState.selectedTtsCharacterVoice);&#10;        panel.add(voiceSelector, gbc);&#10;&#10;        voiceSelector.addItemListener(e -&gt; {&#10;            if (e.getStateChange() == ItemEvent.SELECTED) {&#10;                AppState.selectedTtsCharacterVoice = (String) e.getItem();&#10;                System.out.println(&quot;Voice changed to: &quot; + AppState.selectedTtsCharacterVoice);&#10;                AppState.saveCurrentSettings();&#10;            }&#10;        });&#10;&#10;        // --- Personality Controls ---&#10;        gbc.gridx = 0;&#10;        gbc.gridy = 1;&#10;        gbc.gridwidth = 2;&#10;        panel.add(new JLabel(&quot;Personality:&quot;), gbc);&#10;&#10;        gbc.gridx = 0;&#10;        gbc.gridy = 2;&#10;        gbc.gridwidth = 2;&#10;        JPanel personalityPanel = createPersonalityPanel();&#10;        panel.add(personalityPanel, gbc);&#10;&#10;        // --- Language Controls ---&#10;        gbc.gridx = 0;&#10;        gbc.gridy = 3;&#10;        gbc.gridwidth = 1;&#10;        panel.add(new JLabel(&quot;Language:&quot;), gbc);&#10;&#10;        gbc.gridx = 1;&#10;        gbc.gridy = 3;&#10;        String[] languages = {&quot;English&quot;, &quot;Japanese&quot;, &quot;Chinese&quot;};&#10;        JComboBox&lt;String&gt; languageSelector = new JComboBox&lt;&gt;(languages);&#10;        languageSelector.setSelectedItem(AppState.selectedLanguage);&#10;        panel.add(languageSelector, gbc);&#10;&#10;        languageSelector.addItemListener(e -&gt; {&#10;            if (e.getStateChange() == ItemEvent.SELECTED) {&#10;                AppState.selectedLanguage = (String) e.getItem();&#10;                System.out.println(&quot;Language changed to: &quot; + AppState.selectedLanguage);&#10;                AppState.saveCurrentSettings();&#10;            }&#10;        });&#10;&#10;        // --- Model Type Controls ---&#10;        gbc.gridx = 0;&#10;        gbc.gridy = 4;&#10;        gbc.gridwidth = 1;&#10;        panel.add(new JLabel(&quot;Vision Model:&quot;), gbc);&#10;&#10;        gbc.gridx = 1;&#10;        gbc.gridy = 4;&#10;        gbc.gridwidth = 1;&#10;        JPanel visionModelPanel = createVisionModelPanel();&#10;        panel.add(visionModelPanel, gbc);&#10;&#10;        // --- Analysis Model Controls ---&#10;        gbc.gridx = 0;&#10;        gbc.gridy = 5;&#10;        gbc.gridwidth = 1;&#10;        panel.add(new JLabel(&quot;Analysis Model:&quot;), gbc);&#10;&#10;        gbc.gridx = 1;&#10;        gbc.gridy = 5;&#10;        gbc.gridwidth = 1;&#10;        JPanel analysisModelPanel = createAnalysisModelPanel();&#10;        panel.add(analysisModelPanel, gbc);&#10;&#10;        // --- Start/Stop Button ---&#10;        gbc.gridx = 0;&#10;        gbc.gridy = 6;&#10;        gbc.gridwidth = 2;&#10;        gbc.fill = GridBagConstraints.NONE;&#10;        gbc.anchor = GridBagConstraints.CENTER;&#10;        JButton startStopButton = new JButton(&quot;Start Assistant&quot;);&#10;        startStopButton.addActionListener(e -&gt; {&#10;            if (AppState.isRunning) {&#10;                Main.assistantCore.stopProcessing();&#10;                startStopButton.setText(&quot;Start Assistant&quot;);&#10;            } else {&#10;                Main.assistantCore.startProcessing();&#10;                startStopButton.setText(&quot;Stop Assistant&quot;);&#10;            }&#10;        });&#10;        panel.add(startStopButton, gbc);&#10;&#10;        add(panel);&#10;        setLocationRelativeTo(null);&#10;        setVisible(true);&#10;    }&#10;&#10;    private JPanel createPersonalityPanel() {&#10;        JPanel panel = new JPanel(new FlowLayout(FlowLayout.LEFT));&#10;        ButtonGroup personalityGroup = new ButtonGroup();&#10;&#10;        List&lt;Personality&gt; personalities = AppState.getAvailablePersonalities();&#10;&#10;        if (personalities.isEmpty()) {&#10;            JLabel noPersonalitiesLabel = new JLabel(&quot;No personalities found. Check data folder.&quot;);&#10;            panel.add(noPersonalitiesLabel);&#10;            return panel;&#10;        }&#10;&#10;        for (Personality personality : personalities) {&#10;            JRadioButton radioButton = new JRadioButton(personality.getName());&#10;            personalityGroup.add(radioButton);&#10;&#10;            // Set selected if this is the current personality&#10;            Personality selectedPersonality = AppState.getSelectedPersonality();&#10;            if (selectedPersonality != null &amp;&amp;&#10;                    personality.getName().equals(selectedPersonality.getName())) {&#10;                radioButton.setSelected(true);&#10;            }&#10;&#10;            radioButton.addActionListener(e -&gt; {&#10;                if (radioButton.isSelected()) {&#10;                    AppState.setSelectedPersonality(personality);&#10;                }&#10;            });&#10;&#10;            panel.add(radioButton);&#10;        }&#10;&#10;        return panel;&#10;    }&#10;&#10;    private JPanel createVisionModelPanel() {&#10;        JPanel panel = new JPanel(new FlowLayout(FlowLayout.LEFT));&#10;        ButtonGroup visionModelGroup = new ButtonGroup();&#10;&#10;        JRadioButton localVisionButton = new JRadioButton(&quot;Local&quot;);&#10;        JRadioButton apiVisionButton = new JRadioButton(&quot;API&quot;);&#10;&#10;        visionModelGroup.add(localVisionButton);&#10;        visionModelGroup.add(apiVisionButton);&#10;&#10;        // Set initial selection based on current state&#10;        if (AppState.useApiVision()) {&#10;            apiVisionButton.setSelected(true);&#10;        } else {&#10;            localVisionButton.setSelected(true);&#10;        }&#10;&#10;        // Disable API option if configuration is not available&#10;        if (!AppState.isVisionApiConfigAvailable()) {&#10;            apiVisionButton.setEnabled(false);&#10;            apiVisionButton.setToolTipText(&quot;Vision API configuration not available in data/system/system.json&quot;);&#10;        }&#10;&#10;        localVisionButton.addActionListener(e -&gt; {&#10;            if (localVisionButton.isSelected()) {&#10;                AppState.setUseApiVision(false);&#10;            }&#10;        });&#10;&#10;        apiVisionButton.addActionListener(e -&gt; {&#10;            if (apiVisionButton.isSelected()) {&#10;                AppState.setUseApiVision(true);&#10;            }&#10;        });&#10;&#10;        panel.add(localVisionButton);&#10;        panel.add(apiVisionButton);&#10;&#10;        return panel;&#10;    }&#10;&#10;    private JPanel createAnalysisModelPanel() {&#10;        JPanel panel = new JPanel(new FlowLayout(FlowLayout.LEFT));&#10;        ButtonGroup analysisModelGroup = new ButtonGroup();&#10;&#10;        JRadioButton localAnalysisButton = new JRadioButton(&quot;Local&quot;);&#10;        JRadioButton apiAnalysisButton = new JRadioButton(&quot;API&quot;);&#10;&#10;        analysisModelGroup.add(localAnalysisButton);&#10;        analysisModelGroup.add(apiAnalysisButton);&#10;&#10;        // Set initial selection based on current state&#10;        if (AppState.useApiAnalysis()) {&#10;            apiAnalysisButton.setSelected(true);&#10;        } else {&#10;            localAnalysisButton.setSelected(true);&#10;        }&#10;&#10;        // Disable API option if configuration is not available&#10;        if (!AppState.isAnalysisApiConfigAvailable()) {&#10;            apiAnalysisButton.setEnabled(false);&#10;            apiAnalysisButton.setToolTipText(&quot;Analysis API configuration not available in data/system/system.json&quot;);&#10;        }&#10;&#10;        localAnalysisButton.addActionListener(e -&gt; {&#10;            if (localAnalysisButton.isSelected()) {&#10;                AppState.setUseApiAnalysis(false);&#10;            }&#10;        });&#10;&#10;        apiAnalysisButton.addActionListener(e -&gt; {&#10;            if (apiAnalysisButton.isSelected()) {&#10;                AppState.setUseApiAnalysis(true);&#10;            }&#10;        });&#10;&#10;        panel.add(localAnalysisButton);&#10;        panel.add(apiAnalysisButton);&#10;&#10;        return panel;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import javax.swing.*;&#10;import java.awt.*;&#10;import java.awt.event.ItemEvent;&#10;import java.util.List;&#10;import personality.Personality;&#10;&#10;/**&#10; * Creates the main settings window for the application.&#10; * UPDATED: Now uses the new modular architecture with specialized managers.&#10; */&#10;public class SettingsWindow extends JFrame {&#10;&#10;    public SettingsWindow(String[] voices) {&#10;        setTitle(&quot;AI Assistant Settings&quot;);&#10;        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#10;        setSize(500, 450);&#10;&#10;        JPanel panel = new JPanel(new GridBagLayout());&#10;        GridBagConstraints gbc = new GridBagConstraints();&#10;        gbc.insets = new Insets(5, 10, 5, 10);&#10;        gbc.fill = GridBagConstraints.HORIZONTAL;&#10;&#10;        // --- Voice Controls ---&#10;        gbc.gridx = 0;&#10;        gbc.gridy = 0;&#10;        panel.add(new JLabel(&quot;Assistant Voice:&quot;), gbc);&#10;&#10;        gbc.gridx = 1;&#10;        gbc.gridy = 0;&#10;        JComboBox&lt;String&gt; voiceSelector = new JComboBox&lt;&gt;(voices);&#10;        voiceSelector.setSelectedItem(AppState.selectedTtsCharacterVoice);&#10;        panel.add(voiceSelector, gbc);&#10;&#10;        voiceSelector.addItemListener(e -&gt; {&#10;            if (e.getStateChange() == ItemEvent.SELECTED) {&#10;                AppState.selectedTtsCharacterVoice = (String) e.getItem();&#10;                System.out.println(&quot;Voice changed to: &quot; + AppState.selectedTtsCharacterVoice);&#10;                AppState.saveCurrentSettings();&#10;            }&#10;        });&#10;&#10;        // --- Personality Controls ---&#10;        gbc.gridx = 0;&#10;        gbc.gridy = 1;&#10;        gbc.gridwidth = 2;&#10;        panel.add(new JLabel(&quot;Personality:&quot;), gbc);&#10;&#10;        gbc.gridx = 0;&#10;        gbc.gridy = 2;&#10;        gbc.gridwidth = 2;&#10;        JPanel personalityPanel = createPersonalityPanel();&#10;        panel.add(personalityPanel, gbc);&#10;&#10;        // --- Language Controls ---&#10;        gbc.gridx = 0;&#10;        gbc.gridy = 3;&#10;        gbc.gridwidth = 1;&#10;        panel.add(new JLabel(&quot;Language:&quot;), gbc);&#10;&#10;        gbc.gridx = 1;&#10;        gbc.gridy = 3;&#10;        String[] languages = {&quot;English&quot;, &quot;Japanese&quot;, &quot;Chinese&quot;};&#10;        JComboBox&lt;String&gt; languageSelector = new JComboBox&lt;&gt;(languages);&#10;        languageSelector.setSelectedItem(AppState.selectedLanguage);&#10;        panel.add(languageSelector, gbc);&#10;&#10;        languageSelector.addItemListener(e -&gt; {&#10;            if (e.getStateChange() == ItemEvent.SELECTED) {&#10;                AppState.selectedLanguage = (String) e.getItem();&#10;                System.out.println(&quot;Language changed to: &quot; + AppState.selectedLanguage);&#10;                AppState.saveCurrentSettings();&#10;            }&#10;        });&#10;&#10;        // --- Model Type Controls ---&#10;        gbc.gridx = 0;&#10;        gbc.gridy = 4;&#10;        gbc.gridwidth = 1;&#10;        panel.add(new JLabel(&quot;Vision Model:&quot;), gbc);&#10;&#10;        gbc.gridx = 1;&#10;        gbc.gridy = 4;&#10;        gbc.gridwidth = 1;&#10;        JPanel visionModelPanel = createVisionModelPanel();&#10;        panel.add(visionModelPanel, gbc);&#10;&#10;        // --- Analysis Model Controls ---&#10;        gbc.gridx = 0;&#10;        gbc.gridy = 5;&#10;        gbc.gridwidth = 1;&#10;        panel.add(new JLabel(&quot;Analysis Model:&quot;), gbc);&#10;&#10;        gbc.gridx = 1;&#10;        gbc.gridy = 5;&#10;        gbc.gridwidth = 1;&#10;        JPanel analysisModelPanel = createAnalysisModelPanel();&#10;        panel.add(analysisModelPanel, gbc);&#10;&#10;        // --- Start/Stop Button ---&#10;        gbc.gridx = 0;&#10;        gbc.gridy = 6;&#10;        gbc.gridwidth = 2;&#10;        gbc.fill = GridBagConstraints.NONE;&#10;        gbc.anchor = GridBagConstraints.CENTER;&#10;        JButton startStopButton = new JButton(&quot;Start Assistant&quot;);&#10;        startStopButton.addActionListener(e -&gt; {&#10;            if (AppState.isRunning) {&#10;                Main.assistantCore.stopProcessing();&#10;                startStopButton.setText(&quot;Start Assistant&quot;);&#10;            } else {&#10;                Main.assistantCore.startProcessing();&#10;                startStopButton.setText(&quot;Stop Assistant&quot;);&#10;            }&#10;        });&#10;        panel.add(startStopButton, gbc);&#10;&#10;        add(panel);&#10;        setLocationRelativeTo(null);&#10;        setVisible(true);&#10;    }&#10;&#10;    private JPanel createPersonalityPanel() {&#10;        JPanel panel = new JPanel(new FlowLayout(FlowLayout.LEFT));&#10;        ButtonGroup personalityGroup = new ButtonGroup();&#10;&#10;        List&lt;Personality&gt; personalities = AppState.getAvailablePersonalities();&#10;&#10;        if (personalities.isEmpty()) {&#10;            JLabel noPersonalitiesLabel = new JLabel(&quot;No personalities found. Check data folder.&quot;);&#10;            panel.add(noPersonalitiesLabel);&#10;            return panel;&#10;        }&#10;&#10;        for (Personality personality : personalities) {&#10;            JRadioButton radioButton = new JRadioButton(personality.getName());&#10;            personalityGroup.add(radioButton);&#10;&#10;            // Set selected if this is the current personality&#10;            Personality selectedPersonality = AppState.getSelectedPersonality();&#10;            if (selectedPersonality != null &amp;&amp;&#10;                    personality.getName().equals(selectedPersonality.getName())) {&#10;                radioButton.setSelected(true);&#10;            }&#10;&#10;            radioButton.addActionListener(e -&gt; {&#10;                if (radioButton.isSelected()) {&#10;                    AppState.setSelectedPersonality(personality);&#10;                }&#10;            });&#10;&#10;            panel.add(radioButton);&#10;        }&#10;&#10;        return panel;&#10;    }&#10;&#10;    private JPanel createVisionModelPanel() {&#10;        JPanel panel = new JPanel(new FlowLayout(FlowLayout.LEFT));&#10;        ButtonGroup visionModelGroup = new ButtonGroup();&#10;&#10;        JRadioButton localVisionButton = new JRadioButton(&quot;Local&quot;);&#10;        JRadioButton apiVisionButton = new JRadioButton(&quot;API&quot;);&#10;&#10;        visionModelGroup.add(localVisionButton);&#10;        visionModelGroup.add(apiVisionButton);&#10;&#10;        // Set initial selection based on current state&#10;        if (AppState.useApiVision()) {&#10;            apiVisionButton.setSelected(true);&#10;        } else {&#10;            localVisionButton.setSelected(true);&#10;        }&#10;&#10;        // Disable API option if configuration is not available&#10;        if (!AppState.isVisionApiConfigAvailable()) {&#10;            apiVisionButton.setEnabled(false);&#10;            apiVisionButton.setToolTipText(&quot;Vision API configuration not available in data/system/system.json&quot;);&#10;        }&#10;&#10;        localVisionButton.addActionListener(e -&gt; {&#10;            if (localVisionButton.isSelected()) {&#10;                AppState.setUseApiVision(false);&#10;            }&#10;        });&#10;&#10;        apiVisionButton.addActionListener(e -&gt; {&#10;            if (apiVisionButton.isSelected()) {&#10;                AppState.setUseApiVision(true);&#10;            }&#10;        });&#10;&#10;        panel.add(localVisionButton);&#10;        panel.add(apiVisionButton);&#10;&#10;        return panel;&#10;    }&#10;&#10;    private JPanel createAnalysisModelPanel() {&#10;        JPanel panel = new JPanel(new FlowLayout(FlowLayout.LEFT));&#10;        ButtonGroup analysisModelGroup = new ButtonGroup();&#10;&#10;        JRadioButton localAnalysisButton = new JRadioButton(&quot;Local&quot;);&#10;        JRadioButton apiAnalysisButton = new JRadioButton(&quot;API&quot;);&#10;&#10;        analysisModelGroup.add(localAnalysisButton);&#10;        analysisModelGroup.add(apiAnalysisButton);&#10;&#10;        // Set initial selection based on current state&#10;        if (AppState.useApiAnalysis()) {&#10;            apiAnalysisButton.setSelected(true);&#10;        } else {&#10;            localAnalysisButton.setSelected(true);&#10;        }&#10;&#10;        // Disable API option if configuration is not available&#10;        if (!AppState.isAnalysisApiConfigAvailable()) {&#10;            apiAnalysisButton.setEnabled(false);&#10;            apiAnalysisButton.setToolTipText(&quot;Analysis API configuration not available in data/system/system.json&quot;);&#10;        }&#10;&#10;        localAnalysisButton.addActionListener(e -&gt; {&#10;            if (localAnalysisButton.isSelected()) {&#10;                AppState.setUseApiAnalysis(false);&#10;            }&#10;        });&#10;&#10;        apiAnalysisButton.addActionListener(e -&gt; {&#10;            if (apiAnalysisButton.isSelected()) {&#10;                AppState.setUseApiAnalysis(true);&#10;            }&#10;        });&#10;&#10;        panel.add(localAnalysisButton);&#10;        panel.add(apiAnalysisButton);&#10;&#10;        return panel;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/UserSettings.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/UserSettings.java" />
              <option name="updatedContent" value="import com.google.gson.Gson;&#10;import com.google.gson.GsonBuilder;&#10;import java.io.*;&#10;&#10;/**&#10; * Manages user settings that are persisted across application sessions.&#10; * This class handles loading and saving user preferences to userSettings.json.&#10; */&#10;public class UserSettings {&#10;    private static final String USER_SETTINGS_FILE = &quot;data/system/userSettings.json&quot;;&#10;    &#10;    // User configurable settings&#10;    private String selectedTtsCharacterVoice = null;&#10;    private String selectedLanguage = &quot;English&quot;;&#10;    private String selectedPersonalityName = &quot;Tsundere&quot;;&#10;    private boolean useApiVision = false;&#10;    private boolean useApiAnalysis = false;&#10;    &#10;    // Default constructor&#10;    public UserSettings() {}&#10;    &#10;    /**&#10;     * Loads user settings from the JSON file.&#10;     * If the file doesn't exist, creates a new one with default values.&#10;     */&#10;    public static UserSettings loadUserSettings() {&#10;        File settingsFile = new File(USER_SETTINGS_FILE);&#10;        &#10;        if (!settingsFile.exists()) {&#10;            System.out.println(&quot;User settings file not found. Creating with default values...&quot;);&#10;            UserSettings defaultSettings = new UserSettings();&#10;            defaultSettings.saveUserSettings();&#10;            return defaultSettings;&#10;        }&#10;        &#10;        try (FileReader reader = new FileReader(settingsFile)) {&#10;            Gson gson = new Gson();&#10;            UserSettings settings = gson.fromJson(reader, UserSettings.class);&#10;            System.out.println(&quot;User settings loaded successfully.&quot;);&#10;            return settings != null ? settings : new UserSettings();&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error loading user settings: &quot; + e.getMessage());&#10;            return new UserSettings();&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Saves the current user settings to the JSON file.&#10;     */&#10;    public void saveUserSettings() {&#10;        File settingsFile = new File(USER_SETTINGS_FILE);&#10;        &#10;        // Ensure the directory exists&#10;        File parentDir = settingsFile.getParentFile();&#10;        if (!parentDir.exists()) {&#10;            parentDir.mkdirs();&#10;        }&#10;        &#10;        try (FileWriter writer = new FileWriter(settingsFile)) {&#10;            Gson gson = new GsonBuilder().setPrettyPrinting().create();&#10;            gson.toJson(this, writer);&#10;            System.out.println(&quot;User settings saved successfully.&quot;);&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error saving user settings: &quot; + e.getMessage());&#10;        }&#10;    }&#10;    &#10;    // Getters and setters&#10;    public String getSelectedTtsCharacterVoice() {&#10;        return selectedTtsCharacterVoice;&#10;    }&#10;    &#10;    public void setSelectedTtsCharacterVoice(String selectedTtsCharacterVoice) {&#10;        this.selectedTtsCharacterVoice = selectedTtsCharacterVoice;&#10;    }&#10;    &#10;    public String getSelectedLanguage() {&#10;        return selectedLanguage;&#10;    }&#10;    &#10;    public void setSelectedLanguage(String selectedLanguage) {&#10;        this.selectedLanguage = selectedLanguage;&#10;    }&#10;    &#10;    public String getSelectedPersonalityName() {&#10;        return selectedPersonalityName;&#10;    }&#10;    &#10;    public void setSelectedPersonalityName(String selectedPersonalityName) {&#10;        this.selectedPersonalityName = selectedPersonalityName;&#10;    }&#10;    &#10;    public boolean isUseApiVision() {&#10;        return useApiVision;&#10;    }&#10;    &#10;    public void setUseApiVision(boolean useApiVision) {&#10;        this.useApiVision = useApiVision;&#10;    }&#10;    &#10;    public boolean isUseApiAnalysis() {&#10;        return useApiAnalysis;&#10;    }&#10;    &#10;    public void setUseApiAnalysis(boolean useApiAnalysis) {&#10;        this.useApiAnalysis = useApiAnalysis;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/api/ApiClient.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/api/ApiClient.java" />
              <option name="updatedContent" value="package api;&#10;&#10;import com.google.gson.Gson;&#10;import com.google.gson.JsonObject;&#10;import com.google.gson.JsonParser;&#10;import config.ConfigurationManager;&#10;import config.SystemConfig;&#10;&#10;import javax.imageio.ImageIO;&#10;import java.awt.image.BufferedImage;&#10;import java.io.ByteArrayOutputStream;&#10;import java.io.IOException;&#10;import java.net.URI;&#10;import java.net.http.HttpClient;&#10;import java.net.http.HttpRequest;&#10;import java.net.http.HttpResponse;&#10;import java.time.Duration;&#10;import java.util.Base64;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;/**&#10; * Unified API client for both Vision and Language Model operations.&#10; * Supports both local services and external APIs (Google Gemini).&#10; */&#10;public class ApiClient {&#10;    private static final String OLLAMA_API_URL = &quot;http://localhost:11434/api/generate&quot;;&#10;    private static final String VISION_API_URL = &quot;http://localhost:5002/describe&quot;;&#10;    private static final String LANGUAGE_MODEL = &quot;qwen3:4b&quot;;&#10;    &#10;    private static final Gson gson = new Gson();&#10;    private static final HttpClient httpClient = HttpClient.newBuilder()&#10;            .connectTimeout(Duration.ofSeconds(10))&#10;            .build();&#10;    &#10;    // === Vision API Methods ===&#10;    &#10;    /**&#10;     * Analyzes an image using either local Python service or external Vision API&#10;     */&#10;    public static String analyzeImage(BufferedImage image, String prompt) throws IOException, InterruptedException {&#10;        if (ConfigurationManager.useApiVision() &amp;&amp; ConfigurationManager.isVisionApiAvailable()) {&#10;            return callExternalVisionApi(prompt, image);&#10;        } else {&#10;            return callLocalVisionService(prompt, image);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Calls local Python vision service&#10;     */&#10;    private static String callLocalVisionService(String prompt, BufferedImage image) throws IOException, InterruptedException {&#10;        String base64Image = encodeImageToBase64(image);&#10;        Map&lt;String, String&gt; payload = Map.of(&quot;prompt&quot;, prompt, &quot;image&quot;, base64Image);&#10;        String jsonPayload = gson.toJson(payload);&#10;        &#10;        HttpRequest request = HttpRequest.newBuilder()&#10;                .uri(URI.create(VISION_API_URL))&#10;                .header(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                .timeout(Duration.ofSeconds(60))&#10;                .POST(HttpRequest.BodyPublishers.ofString(jsonPayload))&#10;                .build();&#10;                &#10;        System.out.println(&quot;Sending request to Python vision service...&quot;);&#10;        HttpResponse&lt;String&gt; response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());&#10;        &#10;        if (response.statusCode() == 200) {&#10;            JsonObject jsonObject = JsonParser.parseString(response.body()).getAsJsonObject();&#10;            String description = jsonObject.get(&quot;description&quot;).getAsString();&#10;            return description.replaceAll(&quot;(?i)screenshot&quot;, &quot;activity&quot;);&#10;        } else {&#10;            System.err.printf(&quot;Error from vision service: %d - %s%n&quot;, response.statusCode(), response.body());&#10;            return null;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Calls external vision API (Google Gemini Vision)&#10;     */&#10;    private static String callExternalVisionApi(String prompt, BufferedImage image) throws IOException, InterruptedException {&#10;        SystemConfig.ApiConfig visionConfig = ConfigurationManager.getVisionApiConfig();&#10;        &#10;        if (visionConfig == null) {&#10;            System.err.println(&quot;Vision API configuration not available&quot;);&#10;            return null;&#10;        }&#10;        &#10;        System.out.println(&quot;Using Vision API: &quot; + visionConfig.getModelName());&#10;        String base64Image = encodeImageToBase64(image);&#10;&#10;        // Build the request payload for Google Gemini Vision API&#10;        Map&lt;String, Object&gt; textPart = Map.of(&quot;text&quot;, prompt);&#10;        Map&lt;String, Object&gt; imagePart = Map.of(&#10;            &quot;inline_data&quot;, Map.of(&#10;                &quot;mime_type&quot;, &quot;image/jpeg&quot;,&#10;                &quot;data&quot;, base64Image&#10;            )&#10;        );&#10;&#10;        Map&lt;String, Object&gt; content = Map.of(&#10;            &quot;parts&quot;, List.of(textPart, imagePart)&#10;        );&#10;&#10;        Map&lt;String, Object&gt; payload = Map.of(&#10;            &quot;contents&quot;, List.of(content),&#10;            &quot;generationConfig&quot;, Map.of(&#10;                &quot;temperature&quot;, 0.4,&#10;                &quot;maxOutputTokens&quot;, 200&#10;            )&#10;        );&#10;&#10;        String jsonPayload = gson.toJson(payload);&#10;        String fullUrl = visionConfig.getUrl() + &quot;?key=&quot; + visionConfig.getKey();&#10;        &#10;        HttpRequest request = HttpRequest.newBuilder()&#10;                .uri(URI.create(fullUrl))&#10;                .header(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                .timeout(Duration.ofSeconds(60))&#10;                .POST(HttpRequest.BodyPublishers.ofString(jsonPayload))&#10;                .build();&#10;&#10;        System.out.println(&quot;Sending vision request to: &quot; + visionConfig.getUrl());&#10;        HttpResponse&lt;String&gt; response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());&#10;&#10;        if (response.statusCode() == 200) {&#10;            return parseGeminiVisionResponse(response.body());&#10;        } else {&#10;            System.err.printf(&quot;Vision API error - Status: %d, Response: %s%n&quot;, response.statusCode(), response.body());&#10;            return null;&#10;        }&#10;    }&#10;    &#10;    // === Language Model API Methods ===&#10;    &#10;    /**&#10;     * Generates a response using either local Ollama or external Language Model API&#10;     */&#10;    public static String generateResponse(String prompt) throws IOException, InterruptedException {&#10;        if (ConfigurationManager.useApiAnalysis() &amp;&amp; ConfigurationManager.isAnalysisApiAvailable()) {&#10;            return callExternalLanguageApi(prompt);&#10;        } else {&#10;            return callLocalOllama(prompt);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Calls local Ollama service&#10;     */&#10;    private static String callLocalOllama(String prompt) throws IOException, InterruptedException {&#10;        Map&lt;String, Object&gt; payload = Map.of(&#10;            &quot;model&quot;, LANGUAGE_MODEL,&#10;            &quot;prompt&quot;, prompt,&#10;            &quot;stream&quot;, false,&#10;            &quot;options&quot;, Map.of(&quot;temperature&quot;, 0.7)&#10;        );&#10;        &#10;        String jsonPayload = gson.toJson(payload);&#10;        &#10;        HttpRequest request = HttpRequest.newBuilder()&#10;                .uri(URI.create(OLLAMA_API_URL))&#10;                .header(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                .timeout(Duration.ofSeconds(60))&#10;                .POST(HttpRequest.BodyPublishers.ofString(jsonPayload))&#10;                .build();&#10;                &#10;        System.out.println(&quot;Sending request to Ollama: &quot; + LANGUAGE_MODEL);&#10;        HttpResponse&lt;String&gt; response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());&#10;        &#10;        if (response.statusCode() == 200) {&#10;            JsonObject jsonObject = JsonParser.parseString(response.body()).getAsJsonObject();&#10;            return jsonObject.get(&quot;response&quot;).getAsString();&#10;        } else {&#10;            System.err.printf(&quot;Ollama error - Status: %d, Response: %s%n&quot;, response.statusCode(), response.body());&#10;            return null;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Calls external language model API (Google Gemini)&#10;     */&#10;    private static String callExternalLanguageApi(String prompt) throws IOException, InterruptedException {&#10;        SystemConfig.ApiConfig analysisConfig = ConfigurationManager.getAnalysisApiConfig();&#10;        &#10;        if (analysisConfig == null) {&#10;            System.err.println(&quot;Analysis API configuration not available&quot;);&#10;            return null;&#10;        }&#10;        &#10;        System.out.println(&quot;Using Analysis API: &quot; + analysisConfig.getModelName());&#10;&#10;        // Build the request payload for Google Gemini API&#10;        Map&lt;String, Object&gt; content = Map.of(&#10;            &quot;parts&quot;, List.of(Map.of(&quot;text&quot;, prompt))&#10;        );&#10;&#10;        Map&lt;String, Object&gt; payload = Map.of(&#10;            &quot;contents&quot;, List.of(content),&#10;            &quot;generationConfig&quot;, Map.of(&#10;                &quot;temperature&quot;, 0.7,&#10;                &quot;maxOutputTokens&quot;, 150&#10;            )&#10;        );&#10;&#10;        String jsonPayload = gson.toJson(payload);&#10;        String fullUrl = analysisConfig.getUrl() + &quot;?key=&quot; + analysisConfig.getKey();&#10;&#10;        HttpRequest request = HttpRequest.newBuilder()&#10;                .uri(URI.create(fullUrl))&#10;                .header(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                .timeout(Duration.ofSeconds(60))&#10;                .POST(HttpRequest.BodyPublishers.ofString(jsonPayload))&#10;                .build();&#10;&#10;        System.out.println(&quot;Sending analysis request to: &quot; + analysisConfig.getUrl());&#10;        HttpResponse&lt;String&gt; response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());&#10;&#10;        if (response.statusCode() == 200) {&#10;            return parseGeminiTextResponse(response.body());&#10;        } else {&#10;            System.err.printf(&quot;Analysis API error - Status: %d, Response: %s%n&quot;, response.statusCode(), response.body());&#10;            return null;&#10;        }&#10;    }&#10;    &#10;    // === Utility Methods ===&#10;    &#10;    /**&#10;     * Encodes a BufferedImage to Base64 string&#10;     */&#10;    private static String encodeImageToBase64(BufferedImage image) throws IOException {&#10;        ByteArrayOutputStream baos = new ByteArrayOutputStream();&#10;        ImageIO.write(image, &quot;jpeg&quot;, baos);&#10;        byte[] imageBytes = baos.toByteArray();&#10;        return Base64.getEncoder().encodeToString(imageBytes);&#10;    }&#10;    &#10;    /**&#10;     * Parses Google Gemini Vision API response&#10;     */&#10;    private static String parseGeminiVisionResponse(String responseBody) {&#10;        try {&#10;            JsonObject jsonObject = JsonParser.parseString(responseBody).getAsJsonObject();&#10;            if (jsonObject.has(&quot;candidates&quot;) &amp;&amp; !jsonObject.getAsJsonArray(&quot;candidates&quot;).isEmpty()) {&#10;                JsonObject candidate = jsonObject.getAsJsonArray(&quot;candidates&quot;).get(0).getAsJsonObject();&#10;                if (candidate.has(&quot;content&quot;)) {&#10;                    JsonObject content = candidate.getAsJsonObject(&quot;content&quot;);&#10;                    if (content.has(&quot;parts&quot;) &amp;&amp; !content.getAsJsonArray(&quot;parts&quot;).isEmpty()) {&#10;                        JsonObject part = content.getAsJsonArray(&quot;parts&quot;).get(0).getAsJsonObject();&#10;                        if (part.has(&quot;text&quot;)) {&#10;                            String description = part.get(&quot;text&quot;).getAsString().trim();&#10;                            System.out.println(&quot;Vision API response received successfully&quot;);&#10;                            return description.replaceAll(&quot;(?i)screenshot&quot;, &quot;activity&quot;);&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            System.err.println(&quot;Vision API returned unexpected response format: &quot; + responseBody);&#10;            return null;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error parsing Vision API response: &quot; + e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Parses Google Gemini Text API response&#10;     */&#10;    private static String parseGeminiTextResponse(String responseBody) {&#10;        try {&#10;            JsonObject jsonObject = JsonParser.parseString(responseBody).getAsJsonObject();&#10;            if (jsonObject.has(&quot;candidates&quot;) &amp;&amp; !jsonObject.getAsJsonArray(&quot;candidates&quot;).isEmpty()) {&#10;                JsonObject candidate = jsonObject.getAsJsonArray(&quot;candidates&quot;).get(0).getAsJsonObject();&#10;                if (candidate.has(&quot;content&quot;)) {&#10;                    JsonObject content = candidate.getAsJsonObject(&quot;content&quot;);&#10;                    if (content.has(&quot;parts&quot;) &amp;&amp; !content.getAsJsonArray(&quot;parts&quot;).isEmpty()) {&#10;                        JsonObject part = content.getAsJsonArray(&quot;parts&quot;).get(0).getAsJsonObject();&#10;                        if (part.has(&quot;text&quot;)) {&#10;                            String text = part.get(&quot;text&quot;).getAsString().trim();&#10;                            System.out.println(&quot;Analysis API response received successfully&quot;);&#10;                            return text;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            System.err.println(&quot;Analysis API returned unexpected response format: &quot; + responseBody);&#10;            return null;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error parsing Analysis API response: &quot; + e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/api/TtsApiClient.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/api/TtsApiClient.java" />
              <option name="originalContent" value="package api;&#10;&#10;import com.google.gson.Gson;&#10;import javax.sound.sampled.*;&#10;import java.io.ByteArrayInputStream;&#10;import java.io.InputStream;&#10;import java.net.URI;&#10;import java.net.http.HttpClient;&#10;import java.net.http.HttpRequest;&#10;import java.net.http.HttpResponse;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;/**&#10; * Handles all communication with the Python VITS TTS API server.&#10; * UPDATED: Now works with VITS models and supports multiple languages/characters.&#10; */&#10;public class TtsApiClient {&#10;&#10;    private static final HttpClient client = HttpClient.newHttpClient();&#10;    private static final Gson gson = new Gson();&#10;    private static final String TTS_API_URL = &quot;http://localhost:5005&quot;;&#10;&#10;    public static List&lt;String&gt; getAvailableCharacters() {&#10;        try {&#10;            HttpRequest request = HttpRequest.newBuilder()&#10;                    .uri(URI.create(TTS_API_URL + &quot;/characters&quot;))&#10;                    .GET().build();&#10;            HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());&#10;            if (response.statusCode() == 200) {&#10;                return gson.fromJson(response.body(), new com.google.gson.reflect.TypeToken&lt;List&lt;String&gt;&gt;() {}.getType());&#10;            }&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;        }&#10;        return null;&#10;    }&#10;&#10;    public static void speak(String text, String characterName, double speed, String language) {&#10;        try {&#10;            // Use the characterName directly from the API (no more language mapping)&#10;            // The characterName now comes from the Coqui TTS API speakers list&#10;&#10;            Map&lt;String, Object&gt; payloadMap = Map.of(&#10;                    &quot;text&quot;, text,&#10;                    &quot;character&quot;, characterName,  // Use characterName directly (jenny_female, bella_female, etc.)&#10;                    &quot;speed&quot;, speed&#10;            );&#10;            String jsonPayload = gson.toJson(payloadMap);&#10;&#10;            HttpRequest request = HttpRequest.newBuilder()&#10;                    .uri(URI.create(TTS_API_URL + &quot;/synthesize&quot;))&#10;                    .header(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                    .POST(HttpRequest.BodyPublishers.ofString(jsonPayload))&#10;                    .build();&#10;&#10;            HttpResponse&lt;InputStream&gt; response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());&#10;&#10;            if (response.statusCode() == 200) {&#10;                byte[] audioBytes = response.body().readAllBytes();&#10;                InputStream byteArrayInputStream = new ByteArrayInputStream(audioBytes);&#10;&#10;                try (AudioInputStream sourceStream = AudioSystem.getAudioInputStream(byteArrayInputStream)) {&#10;                    AudioFormat sourceFormat = sourceStream.getFormat();&#10;                    AudioFormat targetFormat = new AudioFormat(&#10;                            AudioFormat.Encoding.PCM_SIGNED,&#10;                            sourceFormat.getSampleRate(),&#10;                            16,&#10;                            sourceFormat.getChannels(),&#10;                            sourceFormat.getChannels() * 2,&#10;                            sourceFormat.getSampleRate(),&#10;                            false&#10;                    );&#10;&#10;                    try (AudioInputStream convertedStream = AudioSystem.getAudioInputStream(targetFormat, sourceStream)) {&#10;                        Clip clip = AudioSystem.getClip();&#10;                        final Object lock = new Object();&#10;&#10;                        clip.addLineListener(event -&gt; {&#10;                            if (event.getType() == LineEvent.Type.STOP) {&#10;                                synchronized (lock) {&#10;                                    lock.notify();&#10;                                }&#10;                            }&#10;                        });&#10;&#10;                        clip.open(convertedStream);&#10;                        clip.start();&#10;                        synchronized (lock) {&#10;                            lock.wait();&#10;                        }&#10;                        clip.close();&#10;                    }&#10;                }&#10;            } else {&#10;                System.err.println(&quot;TTS request failed with status: &quot; + response.statusCode());&#10;            }&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error during TTS playback: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package api;&#10;&#10;import com.google.gson.Gson;&#10;import javax.sound.sampled.*;&#10;import java.io.ByteArrayInputStream;&#10;import java.io.InputStream;&#10;import java.net.URI;&#10;import java.net.http.HttpClient;&#10;import java.net.http.HttpRequest;&#10;import java.net.http.HttpResponse;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;/**&#10; * Handles all communication with the Python VITS TTS API server.&#10; * UPDATED: Now works with VITS models and supports multiple languages/characters.&#10; */&#10;public class TtsApiClient {&#10;&#10;    private static final HttpClient client = HttpClient.newHttpClient();&#10;    private static final Gson gson = new Gson();&#10;    private static final String TTS_API_URL = &quot;http://localhost:5005&quot;;&#10;&#10;    // Interface for UI callbacks to avoid circular dependencies&#10;    public interface UICallback {&#10;        void showSpeakingImage();&#10;        void showSpeechBubble(String text);&#10;        void showStaticImage();&#10;        void hideSpeechBubble();&#10;    }&#10;&#10;    private static UICallback uiCallback = null;&#10;&#10;    /**&#10;     * Sets the UI callback for TTS events&#10;     */&#10;    public static void setUICallback(UICallback callback) {&#10;        uiCallback = callback;&#10;    }&#10;&#10;    public static List&lt;String&gt; getAvailableCharacters() {&#10;        try {&#10;            HttpRequest request = HttpRequest.newBuilder()&#10;                    .uri(URI.create(TTS_API_URL + &quot;/characters&quot;))&#10;                    .GET().build();&#10;            HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());&#10;            if (response.statusCode() == 200) {&#10;                return gson.fromJson(response.body(), new com.google.gson.reflect.TypeToken&lt;List&lt;String&gt;&gt;() {}.getType());&#10;            }&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;        }&#10;        return null;&#10;    }&#10;&#10;    public static void speak(String text, String characterName, double speed, String language) {&#10;        try {&#10;            // Use the characterName directly from the API (no more language mapping)&#10;            // The characterName now comes from the Coqui TTS API speakers list&#10;&#10;            Map&lt;String, Object&gt; payloadMap = Map.of(&#10;                    &quot;text&quot;, text,&#10;                    &quot;character&quot;, characterName,  // Use characterName directly (jenny_female, bella_female, etc.)&#10;                    &quot;speed&quot;, speed&#10;            );&#10;            String jsonPayload = gson.toJson(payloadMap);&#10;&#10;            HttpRequest request = HttpRequest.newBuilder()&#10;                    .uri(URI.create(TTS_API_URL + &quot;/synthesize&quot;))&#10;                    .header(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                    .POST(HttpRequest.BodyPublishers.ofString(jsonPayload))&#10;                    .build();&#10;&#10;            HttpResponse&lt;InputStream&gt; response = client.send(request, HttpResponse.BodyHandlers.ofInputStream());&#10;&#10;            if (response.statusCode() == 200) {&#10;                // Show speaking image and bubble as soon as we get a valid response (when TTS starts)&#10;                if (uiCallback != null) {&#10;                    uiCallback.showSpeakingImage();&#10;                    uiCallback.showSpeechBubble(text);&#10;                }&#10;&#10;                byte[] audioBytes = response.body().readAllBytes();&#10;                InputStream byteArrayInputStream = new ByteArrayInputStream(audioBytes);&#10;&#10;                try (AudioInputStream sourceStream = AudioSystem.getAudioInputStream(byteArrayInputStream)) {&#10;                    AudioFormat sourceFormat = sourceStream.getFormat();&#10;                    AudioFormat targetFormat = new AudioFormat(&#10;                            AudioFormat.Encoding.PCM_SIGNED,&#10;                            sourceFormat.getSampleRate(),&#10;                            16,&#10;                            sourceFormat.getChannels(),&#10;                            sourceFormat.getChannels() * 2,&#10;                            sourceFormat.getSampleRate(),&#10;                            false&#10;                    );&#10;&#10;                    try (AudioInputStream convertedStream = AudioSystem.getAudioInputStream(targetFormat, sourceStream)) {&#10;                        Clip clip = AudioSystem.getClip();&#10;                        final Object lock = new Object();&#10;&#10;                        clip.addLineListener(event -&gt; {&#10;                            if (event.getType() == LineEvent.Type.STOP) {&#10;                                // Revert to static image and hide bubble when TTS finishes&#10;                                if (uiCallback != null) {&#10;                                    uiCallback.showStaticImage();&#10;                                    uiCallback.hideSpeechBubble();&#10;                                }&#10;                                synchronized (lock) {&#10;                                    lock.notify();&#10;                                }&#10;                            }&#10;                        });&#10;&#10;                        clip.open(convertedStream);&#10;                        clip.start();&#10;                        synchronized (lock) {&#10;                            lock.wait();&#10;                        }&#10;                        clip.close();&#10;                    }&#10;                }&#10;            } else {&#10;                System.err.println(&quot;TTS request failed with status: &quot; + response.statusCode());&#10;                // Ensure UI resets on failure&#10;                if (uiCallback != null) {&#10;                    uiCallback.showStaticImage();&#10;                    uiCallback.hideSpeechBubble();&#10;                }&#10;            }&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error during TTS playback: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;            // Ensure UI resets on error&#10;            if (uiCallback != null) {&#10;                uiCallback.showStaticImage();&#10;                uiCallback.hideSpeechBubble();&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/config/ConfigurationManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/config/ConfigurationManager.java" />
              <option name="originalContent" value="package config;&#10;&#10;import com.google.gson.Gson;&#10;import java.io.FileReader;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Manages all configuration loading and access for the application.&#10; * Centralizes system.json and userSettings.json management.&#10; */&#10;public class ConfigurationManager {&#10;    private static SystemConfig systemConfig = null;&#10;    private static UserSettings userSettings = null;&#10;    private static final Gson gson = new Gson();&#10;&#10;    /**&#10;     * Initializes all configuration files.&#10;     * Should be called once at application startup.&#10;     */&#10;    public static void initialize() {&#10;        loadSystemConfig();&#10;        loadUserSettings();&#10;    }&#10;&#10;    /**&#10;     * Loads system configuration from system.json&#10;     */&#10;    private static void loadSystemConfig() {&#10;        systemConfig = SystemConfig.loadSystemConfig();&#10;    }&#10;&#10;    /**&#10;     * Loads user settings from userSettings.json&#10;     */&#10;    private static void loadUserSettings() {&#10;        userSettings = UserSettings.loadUserSettings();&#10;    }&#10;&#10;    /**&#10;     * Saves current user settings to file&#10;     */&#10;    public static void saveUserSettings() {&#10;        if (userSettings != null) {&#10;            userSettings.saveUserSettings();&#10;        }&#10;    }&#10;&#10;    // === System Config Access ===&#10;&#10;    /**&#10;     * Gets the vision API configuration&#10;     */&#10;    public static SystemConfig.ApiConfig getVisionApiConfig() {&#10;        return systemConfig != null ? systemConfig.getVision() : null;&#10;    }&#10;&#10;    /**&#10;     * Gets the analysis API configuration&#10;     */&#10;    public static SystemConfig.ApiConfig getAnalysisApiConfig() {&#10;        return systemConfig != null ? systemConfig.getAnalysis() : null;&#10;    }&#10;&#10;    /**&#10;     * Checks if vision API configuration is available&#10;     */&#10;    public static boolean isVisionApiAvailable() {&#10;        SystemConfig.ApiConfig vision = getVisionApiConfig();&#10;        return vision != null &amp;&amp; vision.getKey() != null &amp;&amp; vision.getUrl() != null;&#10;    }&#10;&#10;    /**&#10;     * Checks if analysis API configuration is available&#10;     */&#10;    public static boolean isAnalysisApiAvailable() {&#10;        SystemConfig.ApiConfig analysis = getAnalysisApiConfig();&#10;        return analysis != null &amp;&amp; analysis.getKey() != null &amp;&amp; analysis.getUrl() != null;&#10;    }&#10;&#10;    // === User Settings Access ===&#10;&#10;    public static UserSettings getUserSettings() {&#10;        return userSettings;&#10;    }&#10;&#10;    public static String getSelectedTtsVoice() {&#10;        return userSettings != null ? userSettings.getSelectedTtsCharacterVoice() : null;&#10;    }&#10;&#10;    public static String getSelectedLanguage() {&#10;        return userSettings != null ? userSettings.getSelectedLanguage() : &quot;English&quot;;&#10;    }&#10;&#10;    public static String getSelectedPersonalityName() {&#10;        return userSettings != null ? userSettings.getSelectedPersonalityName() : &quot;Tsundere&quot;;&#10;    }&#10;&#10;    public static boolean useApiVision() {&#10;        return userSettings != null &amp;&amp; userSettings.isUseApiVision();&#10;    }&#10;&#10;    public static boolean useApiAnalysis() {&#10;        return userSettings != null &amp;&amp; userSettings.isUseApiAnalysis();&#10;    }&#10;&#10;    // === User Settings Updates ===&#10;&#10;    public static void setSelectedTtsVoice(String voice) {&#10;        if (userSettings != null) {&#10;            userSettings.setSelectedTtsCharacterVoice(voice);&#10;            saveUserSettings();&#10;        }&#10;    }&#10;&#10;    public static void setSelectedLanguage(String language) {&#10;        if (userSettings != null) {&#10;            userSettings.setSelectedLanguage(language);&#10;            saveUserSettings();&#10;        }&#10;    }&#10;&#10;    public static void setSelectedPersonality(String personalityName) {&#10;        if (userSettings != null) {&#10;            userSettings.setSelectedPersonalityName(personalityName);&#10;            saveUserSettings();&#10;        }&#10;    }&#10;&#10;    public static void setUseApiVision(boolean useApi) {&#10;        if (userSettings != null) {&#10;            userSettings.setUseApiVision(useApi);&#10;            saveUserSettings();&#10;        }&#10;    }&#10;&#10;    public static void setUseApiAnalysis(boolean useApi) {&#10;        if (userSettings != null) {&#10;            userSettings.setUseApiAnalysis(useApi);&#10;            saveUserSettings();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package config;&#13;&#10;&#13;&#10;import com.google.gson.Gson;&#13;&#10;import java.io.FileReader;&#13;&#10;import java.io.IOException;&#13;&#10;&#13;&#10;/**&#13;&#10; * Manages all configuration loading and access for the application.&#13;&#10; * Centralizes system.json and userSettings.json management.&#13;&#10; */&#13;&#10;public class ConfigurationManager {&#13;&#10;    private static SystemConfig systemConfig = null;&#13;&#10;    private static UserSettings userSettings = null;&#13;&#10;    private static final Gson gson = new Gson();&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Initializes all configuration files.&#13;&#10;     * Should be called once at application startup.&#13;&#10;     */&#13;&#10;    public static void initialize() {&#13;&#10;        loadSystemConfig();&#13;&#10;        loadUserSettings();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Loads system configuration from system.json&#13;&#10;     */&#13;&#10;    private static void loadSystemConfig() {&#13;&#10;        systemConfig = SystemConfig.loadSystemConfig();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Loads user settings from userSettings.json&#13;&#10;     */&#13;&#10;    private static void loadUserSettings() {&#13;&#10;        userSettings = UserSettings.loadUserSettings();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Saves current user settings to file&#13;&#10;     */&#13;&#10;    public static void saveUserSettings() {&#13;&#10;        if (userSettings != null) {&#13;&#10;            userSettings.saveUserSettings();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // === System Config Access ===&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Gets the vision API configuration&#13;&#10;     */&#13;&#10;    public static SystemConfig.ApiConfig getVisionApiConfig() {&#13;&#10;        return systemConfig != null ? systemConfig.getVision() : null;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Gets the analysis API configuration&#13;&#10;     */&#13;&#10;    public static SystemConfig.ApiConfig getAnalysisApiConfig() {&#13;&#10;        return systemConfig != null ? systemConfig.getAnalysis() : null;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Checks if vision API configuration is available&#13;&#10;     */&#13;&#10;    public static boolean isVisionApiAvailable() {&#13;&#10;        SystemConfig.ApiConfig vision = getVisionApiConfig();&#13;&#10;        return vision != null &amp;&amp; vision.getKey() != null &amp;&amp; vision.getUrl() != null;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Checks if analysis API configuration is available&#13;&#10;     */&#13;&#10;    public static boolean isAnalysisApiAvailable() {&#13;&#10;        SystemConfig.ApiConfig analysis = getAnalysisApiConfig();&#13;&#10;        return analysis != null &amp;&amp; analysis.getKey() != null &amp;&amp; analysis.getUrl() != null;&#13;&#10;    }&#13;&#10;&#13;&#10;    // === User Settings Access ===&#13;&#10;&#13;&#10;    public static UserSettings getUserSettings() {&#13;&#10;        return userSettings;&#13;&#10;    }&#13;&#10;&#13;&#10;    public static String getSelectedTtsVoice() {&#13;&#10;        return userSettings != null ? userSettings.getSelectedTtsCharacterVoice() : null;&#13;&#10;    }&#13;&#10;&#13;&#10;    public static String getSelectedLanguage() {&#13;&#10;        return userSettings != null ? userSettings.getSelectedLanguage() : &quot;English&quot;;&#13;&#10;    }&#13;&#10;&#13;&#10;    public static String getSelectedPersonalityName() {&#13;&#10;        return userSettings != null ? userSettings.getSelectedPersonalityName() : &quot;Tsundere&quot;;&#13;&#10;    }&#13;&#10;&#13;&#10;    public static boolean useApiVision() {&#13;&#10;        return userSettings != null &amp;&amp; userSettings.isUseApiVision();&#13;&#10;    }&#13;&#10;&#13;&#10;    public static boolean useApiAnalysis() {&#13;&#10;        return userSettings != null &amp;&amp; userSettings.isUseApiAnalysis();&#13;&#10;    }&#13;&#10;&#13;&#10;    // === User Settings Updates ===&#13;&#10;&#13;&#10;    public static void setSelectedTtsVoice(String voice) {&#13;&#10;        if (userSettings != null) {&#13;&#10;            userSettings.setSelectedTtsCharacterVoice(voice);&#13;&#10;            saveUserSettings();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    public static void setSelectedLanguage(String language) {&#13;&#10;        if (userSettings != null) {&#13;&#10;            userSettings.setSelectedLanguage(language);&#13;&#10;            saveUserSettings();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    public static void setSelectedPersonality(String personalityName) {&#13;&#10;        if (userSettings != null) {&#13;&#10;            userSettings.setSelectedPersonalityName(personalityName);&#13;&#10;            saveUserSettings();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    public static void setUseApiVision(boolean useApi) {&#13;&#10;        if (userSettings != null) {&#13;&#10;            userSettings.setUseApiVision(useApi);&#13;&#10;            saveUserSettings();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    public static void setUseApiAnalysis(boolean useApi) {&#13;&#10;        if (userSettings != null) {&#13;&#10;            userSettings.setUseApiAnalysis(useApi);&#13;&#10;            saveUserSettings();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Gets the vision prompt from system configuration&#13;&#10;     */&#13;&#10;    public static String getVisionPrompt() {&#13;&#10;        return systemConfig != null &amp;&amp; systemConfig.getPrompts() != null ? &#13;&#10;               systemConfig.getPrompts().getVisionPrompt() : &#13;&#10;               &quot;Describe the user's activity in this image. Focus on the content and what they are doing. Do NOT use the words 'screenshot', 'screen', or 'image'.&quot;;&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Gets the fallback prompt from system configuration&#13;&#10;     */&#13;&#10;    public static String getFallbackPrompt() {&#13;&#10;        return systemConfig != null &amp;&amp; systemConfig.getPrompts() != null ? &#13;&#10;               systemConfig.getPrompts().getFallbackPrompt() : &#13;&#10;               &quot;Based on this screen description: \&quot;%s\&quot; Give a SHORT comment (maximum 15 words).&quot;;&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/config/SystemConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/config/SystemConfig.java" />
              <option name="originalContent" value="package config;&#10;&#10;import com.google.gson.Gson;&#10;import java.io.File;&#10;import java.io.FileReader;&#10;import java.io.IOException;&#10;&#10;/**&#10; * Represents the system configuration loaded from data/system/system.json&#10; */&#10;public class SystemConfig {&#10;    private ApiConfig analysis;&#10;    private ApiConfig vision;&#10;&#10;    // Default constructor for Gson&#10;    public SystemConfig() {}&#10;&#10;    public ApiConfig getAnalysis() {&#10;        return analysis;&#10;    }&#10;&#10;    public ApiConfig getVision() {&#10;        return vision;&#10;    }&#10;&#10;    /**&#10;     * Loads system configuration from the system.json file&#10;     */&#10;    public static SystemConfig loadSystemConfig() {&#10;        File configFile = new File(&quot;data/system/system.json&quot;);&#10;        if (!configFile.exists()) {&#10;            System.err.println(&quot;System config file not found: &quot; + configFile.getAbsolutePath());&#10;            return null;&#10;        }&#10;&#10;        try (FileReader reader = new FileReader(configFile)) {&#10;            Gson gson = new Gson();&#10;            SystemConfig config = gson.fromJson(reader, SystemConfig.class);&#10;            System.out.println(&quot;System configuration loaded successfully&quot;);&#10;            return config;&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error loading system config: &quot; + e.getMessage());&#10;            return null;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Represents an API configuration (analysis or vision)&#10;     */&#10;    public static class ApiConfig {&#10;        private String key;&#10;        private String modelName;&#10;        private String url;&#10;&#10;        // Default constructor for Gson&#10;        public ApiConfig() {}&#10;&#10;        public String getKey() {&#10;            return key;&#10;        }&#10;&#10;        public String getModelName() {&#10;            return modelName;&#10;        }&#10;&#10;        public String getUrl() {&#10;            return url;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package config;&#13;&#10;&#13;&#10;import com.google.gson.Gson;&#13;&#10;import java.io.File;&#13;&#10;import java.io.FileReader;&#13;&#10;import java.io.IOException;&#13;&#10;&#13;&#10;/**&#13;&#10; * Represents the system configuration loaded from data/system/system.json&#13;&#10; */&#13;&#10;public class SystemConfig {&#13;&#10;    private ApiConfig analysis;&#13;&#10;    private ApiConfig vision;&#13;&#10;    private PromptsConfig prompts;&#13;&#10;&#13;&#10;    // Default constructor for Gson&#13;&#10;    public SystemConfig() {}&#13;&#10;&#13;&#10;    public ApiConfig getAnalysis() {&#13;&#10;        return analysis;&#13;&#10;    }&#13;&#10;&#13;&#10;    public ApiConfig getVision() {&#13;&#10;        return vision;&#13;&#10;    }&#13;&#10;    &#13;&#10;    public PromptsConfig getPrompts() {&#13;&#10;        return prompts;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Loads system configuration from the system.json file&#13;&#10;     */&#13;&#10;    public static SystemConfig loadSystemConfig() {&#13;&#10;        File configFile = new File(&quot;data/system/system.json&quot;);&#13;&#10;        if (!configFile.exists()) {&#13;&#10;            System.err.println(&quot;System config file not found: &quot; + configFile.getAbsolutePath());&#13;&#10;            return null;&#13;&#10;        }&#13;&#10;&#13;&#10;        try (FileReader reader = new FileReader(configFile)) {&#13;&#10;            Gson gson = new Gson();&#13;&#10;            SystemConfig config = gson.fromJson(reader, SystemConfig.class);&#13;&#10;            System.out.println(&quot;System configuration loaded successfully&quot;);&#13;&#10;            return config;&#13;&#10;        } catch (IOException e) {&#13;&#10;            System.err.println(&quot;Error loading system config: &quot; + e.getMessage());&#13;&#10;            return null;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Represents an API configuration (analysis or vision)&#13;&#10;     */&#13;&#10;    public static class ApiConfig {&#13;&#10;        private String key;&#13;&#10;        private String modelName;&#13;&#10;        private String url;&#13;&#10;&#13;&#10;        // Default constructor for Gson&#13;&#10;        public ApiConfig() {}&#13;&#10;&#13;&#10;        public String getKey() {&#13;&#10;            return key;&#13;&#10;        }&#13;&#10;&#13;&#10;        public String getModelName() {&#13;&#10;            return modelName;&#13;&#10;        }&#13;&#10;&#13;&#10;        public String getUrl() {&#13;&#10;            return url;&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Represents prompts configuration&#13;&#10;     */&#13;&#10;    public static class PromptsConfig {&#13;&#10;        private String visionPrompt;&#13;&#10;        private String fallbackPrompt;&#13;&#10;&#13;&#10;        // Default constructor for Gson&#13;&#10;        public PromptsConfig() {}&#13;&#10;&#13;&#10;        public String getVisionPrompt() {&#13;&#10;            return visionPrompt != null ? visionPrompt : &#13;&#10;                &quot;Describe the user's activity in this image. Focus on the content and what they are doing. Do NOT use the words 'screenshot', 'screen', or 'image'.&quot;;&#13;&#10;        }&#13;&#10;&#13;&#10;        public String getFallbackPrompt() {&#13;&#10;            return fallbackPrompt != null ? fallbackPrompt : &#13;&#10;                &quot;Based on this screen description: \&quot;%s\&quot; Give a SHORT comment (maximum 15 words).&quot;;&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/config/UserSettings.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/config/UserSettings.java" />
              <option name="originalContent" value="import com.google.gson.Gson;&#10;import com.google.gson.GsonBuilder;&#10;import java.io.*;&#10;&#10;/**&#10; * Manages user settings that are persisted across application sessions.&#10; * This class handles loading and saving user preferences to userSettings.json.&#10; */&#10;public class UserSettings {&#10;    private static final String USER_SETTINGS_FILE = &quot;data/system/userSettings.json&quot;;&#10;&#10;    // User configurable settings&#10;    private String selectedTtsCharacterVoice = null;&#10;    private String selectedLanguage = &quot;English&quot;;&#10;    private String selectedPersonalityName = &quot;Tsundere&quot;;&#10;    private boolean useApiVision = true;&#10;    private boolean useApiAnalysis = true;&#10;&#10;    // Default constructor&#10;    public UserSettings() {}&#10;&#10;    /**&#10;     * Loads user settings from the JSON file.&#10;     * If the file doesn't exist, creates a new one with default values.&#10;     */&#10;    public static UserSettings loadUserSettings() {&#10;        File settingsFile = new File(USER_SETTINGS_FILE);&#10;&#10;        if (!settingsFile.exists()) {&#10;            System.out.println(&quot;User settings file not found. Creating with default values...&quot;);&#10;            UserSettings defaultSettings = new UserSettings();&#10;            defaultSettings.saveUserSettings();&#10;            return defaultSettings;&#10;        }&#10;&#10;        try (FileReader reader = new FileReader(settingsFile)) {&#10;            Gson gson = new Gson();&#10;            UserSettings settings = gson.fromJson(reader, UserSettings.class);&#10;            System.out.println(&quot;User settings loaded successfully.&quot;);&#10;            return settings != null ? settings : new UserSettings();&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error loading user settings: &quot; + e.getMessage());&#10;            return new UserSettings();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Saves the current user settings to the JSON file.&#10;     */&#10;    public void saveUserSettings() {&#10;        File settingsFile = new File(USER_SETTINGS_FILE);&#10;&#10;        // Ensure the directory exists&#10;        File parentDir = settingsFile.getParentFile();&#10;        if (!parentDir.exists()) {&#10;            parentDir.mkdirs();&#10;        }&#10;&#10;        try (FileWriter writer = new FileWriter(settingsFile)) {&#10;            Gson gson = new GsonBuilder().setPrettyPrinting().create();&#10;            gson.toJson(this, writer);&#10;            System.out.println(&quot;User settings saved successfully.&quot;);&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error saving user settings: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    // Getters and setters&#10;    public String getSelectedTtsCharacterVoice() {&#10;        return selectedTtsCharacterVoice;&#10;    }&#10;&#10;    public void setSelectedTtsCharacterVoice(String selectedTtsCharacterVoice) {&#10;        this.selectedTtsCharacterVoice = selectedTtsCharacterVoice;&#10;    }&#10;&#10;    public String getSelectedLanguage() {&#10;        return selectedLanguage;&#10;    }&#10;&#10;    public void setSelectedLanguage(String selectedLanguage) {&#10;        this.selectedLanguage = selectedLanguage;&#10;    }&#10;&#10;    public String getSelectedPersonalityName() {&#10;        return selectedPersonalityName;&#10;    }&#10;&#10;    public void setSelectedPersonalityName(String selectedPersonalityName) {&#10;        this.selectedPersonalityName = selectedPersonalityName;&#10;    }&#10;&#10;    public boolean isUseApiVision() {&#10;        return useApiVision;&#10;    }&#10;&#10;    public void setUseApiVision(boolean useApiVision) {&#10;        this.useApiVision = useApiVision;&#10;    }&#10;&#10;    public boolean isUseApiAnalysis() {&#10;        return useApiAnalysis;&#10;    }&#10;&#10;    public void setUseApiAnalysis(boolean useApiAnalysis) {&#10;        this.useApiAnalysis = useApiAnalysis;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package config;&#13;&#10;&#13;&#10;import com.google.gson.Gson;&#13;&#10;import com.google.gson.GsonBuilder;&#13;&#10;import java.io.*;&#13;&#10;&#13;&#10;/**&#13;&#10; * Manages user settings that are persisted across application sessions.&#13;&#10; * This class handles loading and saving user preferences to userSettings.json.&#13;&#10; */&#13;&#10;public class UserSettings {&#13;&#10;    private static final String USER_SETTINGS_FILE = &quot;data/system/userSettings.json&quot;;&#13;&#10;&#13;&#10;    // User configurable settings&#13;&#10;    private String selectedTtsCharacterVoice = null;&#13;&#10;    private String selectedLanguage = &quot;English&quot;;&#13;&#10;    private String selectedPersonalityName = &quot;Tsundere&quot;;&#13;&#10;    private boolean useApiVision = true;&#13;&#10;    private boolean useApiAnalysis = true;&#13;&#10;&#13;&#10;    // Default constructor&#13;&#10;    public UserSettings() {}&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Loads user settings from the JSON file.&#13;&#10;     * If the file doesn't exist, creates a new one with default values.&#13;&#10;     */&#13;&#10;    public static UserSettings loadUserSettings() {&#13;&#10;        File settingsFile = new File(USER_SETTINGS_FILE);&#13;&#10;&#13;&#10;        if (!settingsFile.exists()) {&#13;&#10;            System.out.println(&quot;User settings file not found. Creating with default values...&quot;);&#13;&#10;            UserSettings defaultSettings = new UserSettings();&#13;&#10;            defaultSettings.saveUserSettings();&#13;&#10;            return defaultSettings;&#13;&#10;        }&#13;&#10;&#13;&#10;        try (FileReader reader = new FileReader(settingsFile)) {&#13;&#10;            Gson gson = new Gson();&#13;&#10;            UserSettings settings = gson.fromJson(reader, UserSettings.class);&#13;&#10;            System.out.println(&quot;User settings loaded successfully.&quot;);&#13;&#10;            return settings != null ? settings : new UserSettings();&#13;&#10;        } catch (IOException e) {&#13;&#10;            System.err.println(&quot;Error loading user settings: &quot; + e.getMessage());&#13;&#10;            return new UserSettings();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Saves the current user settings to the JSON file.&#13;&#10;     */&#13;&#10;    public void saveUserSettings() {&#13;&#10;        File settingsFile = new File(USER_SETTINGS_FILE);&#13;&#10;&#13;&#10;        // Ensure the directory exists&#13;&#10;        File parentDir = settingsFile.getParentFile();&#13;&#10;        if (!parentDir.exists()) {&#13;&#10;            parentDir.mkdirs();&#13;&#10;        }&#13;&#10;&#13;&#10;        try (FileWriter writer = new FileWriter(settingsFile)) {&#13;&#10;            Gson gson = new GsonBuilder().setPrettyPrinting().create();&#13;&#10;            gson.toJson(this, writer);&#13;&#10;            System.out.println(&quot;User settings saved successfully.&quot;);&#13;&#10;        } catch (IOException e) {&#13;&#10;            System.err.println(&quot;Error saving user settings: &quot; + e.getMessage());&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Getters and setters&#13;&#10;    public String getSelectedTtsCharacterVoice() {&#13;&#10;        return selectedTtsCharacterVoice;&#13;&#10;    }&#13;&#10;&#13;&#10;    public void setSelectedTtsCharacterVoice(String selectedTtsCharacterVoice) {&#13;&#10;        this.selectedTtsCharacterVoice = selectedTtsCharacterVoice;&#13;&#10;    }&#13;&#10;&#13;&#10;    public String getSelectedLanguage() {&#13;&#10;        return selectedLanguage;&#13;&#10;    }&#13;&#10;&#13;&#10;    public void setSelectedLanguage(String selectedLanguage) {&#13;&#10;        this.selectedLanguage = selectedLanguage;&#13;&#10;    }&#13;&#10;&#13;&#10;    public String getSelectedPersonalityName() {&#13;&#10;        return selectedPersonalityName;&#13;&#10;    }&#13;&#10;&#13;&#10;    public void setSelectedPersonalityName(String selectedPersonalityName) {&#13;&#10;        this.selectedPersonalityName = selectedPersonalityName;&#13;&#10;    }&#13;&#10;&#13;&#10;    public boolean isUseApiVision() {&#13;&#10;        return useApiVision;&#13;&#10;    }&#13;&#10;&#13;&#10;    public void setUseApiVision(boolean useApiVision) {&#13;&#10;        this.useApiVision = useApiVision;&#13;&#10;    }&#13;&#10;&#13;&#10;    public boolean isUseApiAnalysis() {&#13;&#10;        return useApiAnalysis;&#13;&#10;    }&#13;&#10;&#13;&#10;    public void setUseApiAnalysis(boolean useApiAnalysis) {&#13;&#10;        this.useApiAnalysis = useApiAnalysis;&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/personality/Personality.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/personality/Personality.java" />
              <option name="originalContent" value="import java.util.List;&#10;&#10;/**&#10; * Represents a personality configuration for the AI assistant.&#10; * UPDATED: Now includes a 'lastResponse' field to act as short-term memory.&#10; */&#10;public class Personality {&#10;    // These fields are loaded from JSON&#10;    private String name;&#10;    private String prompt;&#10;    private List&lt;String&gt; attributes;&#10;&#10;    // These fields are set programmatically&#10;    private transient String staticImagePath;&#10;    private transient String speakingImagePath;&#10;    private transient String lastResponse = &quot;&quot;; // Short-term memory for the last spoken line&#10;&#10;    // Default constructor for Gson&#10;    public Personality() {}&#10;&#10;    public String getName() {&#10;        return name;&#10;    }&#10;&#10;    public void setName(String name) {&#10;        this.name = name;&#10;    }&#10;&#10;    public String getPrompt() {&#10;        return prompt;&#10;    }&#10;&#10;    public void setPrompt(String prompt) {&#10;        this.prompt = prompt;&#10;    }&#10;&#10;    public List&lt;String&gt; getAttributes() {&#10;        return attributes;&#10;    }&#10;&#10;    public void setAttributes(List&lt;String&gt; attributes) {&#10;        this.attributes = attributes;&#10;    }&#10;&#10;    public String getStaticImagePath() {&#10;        return staticImagePath;&#10;    }&#10;&#10;    public void setStaticImagePath(String staticImagePath) {&#10;        this.staticImagePath = staticImagePath;&#10;    }&#10;&#10;    public String getSpeakingImagePath() {&#10;        return speakingImagePath;&#10;    }&#10;&#10;    public void setSpeakingImagePath(String speakingImagePath) {&#10;        this.speakingImagePath = speakingImagePath;&#10;    }&#10;&#10;    public String getLastResponse() {&#10;        return lastResponse;&#10;    }&#10;&#10;    public void setLastResponse(String lastResponse) {&#10;        this.lastResponse = lastResponse;&#10;    }&#10;&#10;    @Override&#10;    public String toString() {&#10;        return name;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package personality;&#13;&#10;&#13;&#10;import java.util.List;&#13;&#10;&#13;&#10;/**&#13;&#10; * Represents a personality configuration for the AI assistant.&#13;&#10; * UPDATED: Now includes a 'lastResponse' field to act as short-term memory.&#13;&#10; */&#13;&#10;public class Personality {&#13;&#10;    // These fields are loaded from JSON&#13;&#10;    private String name;&#13;&#10;    private String prompt;&#13;&#10;    private List&lt;String&gt; attributes;&#13;&#10;&#13;&#10;    // These fields are set programmatically&#13;&#10;    private transient String staticImagePath;&#13;&#10;    private transient String speakingImagePath;&#13;&#10;    private transient String lastResponse = &quot;&quot;; // Short-term memory for the last spoken line&#13;&#10;&#13;&#10;    // Default constructor for Gson&#13;&#10;    public Personality() {}&#13;&#10;&#13;&#10;    public String getName() {&#13;&#10;        return name;&#13;&#10;    }&#13;&#10;&#13;&#10;    public void setName(String name) {&#13;&#10;        this.name = name;&#13;&#10;    }&#13;&#10;&#13;&#10;    public String getPrompt() {&#13;&#10;        return prompt;&#13;&#10;    }&#13;&#10;&#13;&#10;    public void setPrompt(String prompt) {&#13;&#10;        this.prompt = prompt;&#13;&#10;    }&#13;&#10;&#13;&#10;    public List&lt;String&gt; getAttributes() {&#13;&#10;        return attributes;&#13;&#10;    }&#13;&#10;&#13;&#10;    public void setAttributes(List&lt;String&gt; attributes) {&#13;&#10;        this.attributes = attributes;&#13;&#10;    }&#13;&#10;&#13;&#10;    public String getStaticImagePath() {&#13;&#10;        return staticImagePath;&#13;&#10;    }&#13;&#10;&#13;&#10;    public void setStaticImagePath(String staticImagePath) {&#13;&#10;        this.staticImagePath = staticImagePath;&#13;&#10;    }&#13;&#10;&#13;&#10;    public String getSpeakingImagePath() {&#13;&#10;        return speakingImagePath;&#13;&#10;    }&#13;&#10;&#13;&#10;    public void setSpeakingImagePath(String speakingImagePath) {&#13;&#10;        this.speakingImagePath = speakingImagePath;&#13;&#10;    }&#13;&#10;&#13;&#10;    public String getLastResponse() {&#13;&#10;        return lastResponse;&#13;&#10;    }&#13;&#10;&#13;&#10;    public void setLastResponse(String lastResponse) {&#13;&#10;        this.lastResponse = lastResponse;&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public String toString() {&#13;&#10;        return name;&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/personality/PersonalityManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/personality/PersonalityManager.java" />
              <option name="originalContent" value="package personality;&#10;&#10;import com.google.gson.Gson;&#10;import java.io.File;&#10;import java.io.FileReader;&#10;import java.io.IOException;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Manages all personality-related operations including loading, selection, and access.&#10; */&#10;public class PersonalityManager {&#10;    private static final String PERSONALITIES_FOLDER = &quot;data/personalities&quot;;&#10;    private static final List&lt;Personality&gt; availablePersonalities = new ArrayList&lt;&gt;();&#10;    private static Personality selectedPersonality = null;&#10;    private static final Gson gson = new Gson();&#10;&#10;    /**&#10;     * Loads all personality JSON files and constructs their image paths.&#10;     */&#10;    public static void loadPersonalities() {&#10;        availablePersonalities.clear();&#10;&#10;        File personalitiesDir = new File(PERSONALITIES_FOLDER);&#10;        if (!personalitiesDir.exists() || !personalitiesDir.isDirectory()) {&#10;            System.err.println(&quot;Personalities folder not found: &quot; + personalitiesDir.getAbsolutePath());&#10;            return;&#10;        }&#10;&#10;        File[] jsonFiles = personalitiesDir.listFiles((dir, name) -&gt; name.toLowerCase().endsWith(&quot;.json&quot;));&#10;        if (jsonFiles == null || jsonFiles.length == 0) {&#10;            System.err.println(&quot;No personality JSON files found in: &quot; + personalitiesDir.getAbsolutePath());&#10;            return;&#10;        }&#10;&#10;        for (File file : jsonFiles) {&#10;            try (FileReader reader = new FileReader(file)) {&#10;                Personality personality = gson.fromJson(reader, Personality.class);&#10;                if (personality != null &amp;&amp; personality.getName() != null) {&#10;                    // Programmatically set the image paths based on the personality name&#10;                    String imageFolderName = personality.getName();&#10;                    String imageFolderPath = PERSONALITIES_FOLDER + File.separator + imageFolderName;&#10;                    personality.setStaticImagePath(imageFolderPath + File.separator + &quot;static.png&quot;);&#10;                    personality.setSpeakingImagePath(imageFolderPath + File.separator + &quot;speaking.png&quot;);&#10;&#10;                    availablePersonalities.add(personality);&#10;                    System.out.println(&quot;Loaded personality: &quot; + personality.getName());&#10;                }&#10;            } catch (IOException e) {&#10;                System.err.println(&quot;Error loading personality from &quot; + file.getName() + &quot;: &quot; + e.getMessage());&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Sets the selected personality and applies it to user settings.&#10;     */&#10;    public static void setSelectedPersonality(Personality personality) {&#10;        if (personality != null) {&#10;            selectedPersonality = personality;&#10;            System.out.println(&quot;Personality changed to: &quot; + personality.getName());&#10;&#10;            // Save to user settings&#10;            config.ConfigurationManager.setSelectedPersonality(personality.getName());&#10;&#10;            // Notify UI if available&#10;            if (Main.characterUI != null) {&#10;                Main.characterUI.updatePersonalityImages();&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Applies the selected personality from user settings after personalities are loaded.&#10;     */&#10;    public static void applyPersonalityFromSettings() {&#10;        String personalityName = config.ConfigurationManager.getSelectedPersonalityName();&#10;&#10;        if (personalityName != null) {&#10;            selectedPersonality = availablePersonalities.stream()&#10;                    .filter(p -&gt; personalityName.equalsIgnoreCase(p.getName()))&#10;                    .findFirst()&#10;                    .orElse(null);&#10;&#10;            if (selectedPersonality != null) {&#10;                System.out.println(&quot;Personality set from user settings: &quot; + selectedPersonality.getName());&#10;                return;&#10;            }&#10;        }&#10;&#10;        // Fallback if no personality was set from settings&#10;        if (!availablePersonalities.isEmpty()) {&#10;            selectedPersonality = availablePersonalities.stream()&#10;                    .filter(p -&gt; &quot;Tsundere&quot;.equalsIgnoreCase(p.getName()))&#10;                    .findFirst()&#10;                    .orElse(availablePersonalities.get(0));&#10;            System.out.println(&quot;Default personality set to: &quot; + selectedPersonality.getName());&#10;        }&#10;    }&#10;&#10;    // === Getters ===&#10;&#10;    public static List&lt;Personality&gt; getAvailablePersonalities() {&#10;        return new ArrayList&lt;&gt;(availablePersonalities);&#10;    }&#10;&#10;    public static Personality getSelectedPersonality() {&#10;        return selectedPersonality;&#10;    }&#10;&#10;    public static String getCurrentPersonalityPrompt() {&#10;        return selectedPersonality != null ? selectedPersonality.getPrompt() : null;&#10;    }&#10;&#10;    /**&#10;     * Gets the last response from the selected personality for memory purposes.&#10;     */&#10;    public static String getLastResponse() {&#10;        return selectedPersonality != null ? selectedPersonality.getLastResponse() : null;&#10;    }&#10;&#10;    /**&#10;     * Saves a response to the selected personality's memory.&#10;     */&#10;    public static void saveResponseToMemory(String response) {&#10;        if (selectedPersonality != null) {&#10;            selectedPersonality.setLastResponse(response);&#10;            System.out.println(&quot;Saved to memory: \&quot;&quot; + response + &quot;\&quot;&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package personality;&#10;&#10;import com.google.gson.Gson;&#10;import java.io.File;&#10;import java.io.FileReader;&#10;import java.io.IOException;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;/**&#10; * Manages all personality-related operations including loading, selection, and access.&#10; */&#10;public class PersonalityManager {&#10;    private static final String PERSONALITIES_FOLDER = &quot;data/personalities&quot;;&#10;    private static final List&lt;Personality&gt; availablePersonalities = new ArrayList&lt;&gt;();&#10;    private static Personality selectedPersonality = null;&#10;    private static final Gson gson = new Gson();&#10;&#10;    /**&#10;     * Loads all personality JSON files and constructs their image paths.&#10;     */&#10;    public static void loadPersonalities() {&#10;        availablePersonalities.clear();&#10;&#10;        File personalitiesDir = new File(PERSONALITIES_FOLDER);&#10;        if (!personalitiesDir.exists() || !personalitiesDir.isDirectory()) {&#10;            System.err.println(&quot;Personalities folder not found: &quot; + personalitiesDir.getAbsolutePath());&#10;            return;&#10;        }&#10;&#10;        File[] jsonFiles = personalitiesDir.listFiles((dir, name) -&gt; name.toLowerCase().endsWith(&quot;.json&quot;));&#10;        if (jsonFiles == null || jsonFiles.length == 0) {&#10;            System.err.println(&quot;No personality JSON files found in: &quot; + personalitiesDir.getAbsolutePath());&#10;            return;&#10;        }&#10;&#10;        for (File file : jsonFiles) {&#10;            try (FileReader reader = new FileReader(file)) {&#10;                Personality personality = gson.fromJson(reader, Personality.class);&#10;                if (personality != null &amp;&amp; personality.getName() != null) {&#10;                    // Programmatically set the image paths based on the personality name&#10;                    String imageFolderName = personality.getName();&#10;                    String imageFolderPath = PERSONALITIES_FOLDER + File.separator + imageFolderName;&#10;                    personality.setStaticImagePath(imageFolderPath + File.separator + &quot;static.png&quot;);&#10;                    personality.setSpeakingImagePath(imageFolderPath + File.separator + &quot;speaking.png&quot;);&#10;&#10;                    availablePersonalities.add(personality);&#10;                    System.out.println(&quot;Loaded personality: &quot; + personality.getName());&#10;                }&#10;            } catch (IOException e) {&#10;                System.err.println(&quot;Error loading personality from &quot; + file.getName() + &quot;: &quot; + e.getMessage());&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Sets the selected personality and applies it to user settings.&#10;     */&#10;    public static void setSelectedPersonality(Personality personality) {&#10;        if (personality != null) {&#10;            selectedPersonality = personality;&#10;            System.out.println(&quot;Personality changed to: &quot; + personality.getName());&#10;            &#10;            // Save to user settings&#10;            config.ConfigurationManager.setSelectedPersonality(personality.getName());&#10;            &#10;            // Note: UI updates are handled by the calling code to avoid circular dependencies&#10;            // The caller should call updatePersonalityImages() on the UI after this method&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Applies the selected personality from user settings after personalities are loaded.&#10;     */&#10;    public static void applyPersonalityFromSettings() {&#10;        String personalityName = config.ConfigurationManager.getSelectedPersonalityName();&#10;&#10;        if (personalityName != null) {&#10;            selectedPersonality = availablePersonalities.stream()&#10;                    .filter(p -&gt; personalityName.equalsIgnoreCase(p.getName()))&#10;                    .findFirst()&#10;                    .orElse(null);&#10;&#10;            if (selectedPersonality != null) {&#10;                System.out.println(&quot;Personality set from user settings: &quot; + selectedPersonality.getName());&#10;                return;&#10;            }&#10;        }&#10;&#10;        // Fallback if no personality was set from settings&#10;        if (!availablePersonalities.isEmpty()) {&#10;            selectedPersonality = availablePersonalities.stream()&#10;                    .filter(p -&gt; &quot;Tsundere&quot;.equalsIgnoreCase(p.getName()))&#10;                    .findFirst()&#10;                    .orElse(availablePersonalities.get(0));&#10;            System.out.println(&quot;Default personality set to: &quot; + selectedPersonality.getName());&#10;        }&#10;    }&#10;&#10;    // === Getters ===&#10;&#10;    public static List&lt;Personality&gt; getAvailablePersonalities() {&#10;        return new ArrayList&lt;&gt;(availablePersonalities);&#10;    }&#10;&#10;    public static Personality getSelectedPersonality() {&#10;        return selectedPersonality;&#10;    }&#10;&#10;    public static String getCurrentPersonalityPrompt() {&#10;        return selectedPersonality != null ? selectedPersonality.getPrompt() : null;&#10;    }&#10;&#10;    /**&#10;     * Gets the last response from the selected personality for memory purposes.&#10;     */&#10;    public static String getLastResponse() {&#10;        return selectedPersonality != null ? selectedPersonality.getLastResponse() : null;&#10;    }&#10;&#10;    /**&#10;     * Saves a response to the selected personality's memory.&#10;     */&#10;    public static void saveResponseToMemory(String response) {&#10;        if (selectedPersonality != null) {&#10;            selectedPersonality.setLastResponse(response);&#10;            System.out.println(&quot;Saved to memory: \&quot;&quot; + response + &quot;\&quot;&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>